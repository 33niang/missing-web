---
title: 「程序」是怎样炼成的
type: docs
draft: true
---

# 「程序」是怎样炼成的

{{<hint danger>}}
🚧本章仍在施工中，内容并不完整且会发生变化，仅供先行阅读参考。
{{</hint>}}

{{<hint info>}}
近些年，仿佛有一股「少儿编程」「全民编程」之风席卷了中国：在大街小巷上，「编程辅导」的广告层出不穷；在中小学校里，程序设计的知识走进了课堂。即使你已经步入职场，类似「学编程知识，提升『生产力』」之类的培训广告仍然随处可见。在这股浪潮之下，我们有必要先回答一个更基本的问题——「程序」是什么？看完这一章，你将可以找到这些问题的答案：

- 什么是「程序」？「编程」是要做什么？
- 什么是 Python、C 语言、C++、Java……
- 程序是如何在电脑的硬件上运行的？

{{</hint>}}

早在《你缺计课》的第一章 [认识你的电脑]({{<ref "computer-and-its-components.md">}}) 我们就介绍过，电脑是由「硬件」和「软件」有机组成的整体。事实上，平板电脑、手机、智能手表——我们身边的一切智能设备，都由硬件和软件组成。这其中，「硬件」对应着电路、芯片以及各种外部设备，而软件就对应着各种各样的**计算机程序**，简称**程序**。

我们在电脑上使用的 Word 和浏览器、在手机上聊着的微信和 QQ、在平板上看着的各种视频 app，它们就是一个个程序。而 Windows、iOS、安卓这些操作系统，它们亦是一类特殊的程序。人们把「编写程序」的过程简称「编程」，这是今天许多人的工作。也许你对这项工作充满了好奇：我们今天使用的各种各样的程序，是如何被设计出来的呢？又或许你会疑惑：这些千变万化的程序，是怎么在冷冰冰的硬件上运行的呢？本章就让我们揭开「程序」这个熟悉又陌生之物的面纱，带你了解它背后的秘密。

## 程序？菜谱！

### 化繁为简的程序思维

让我们先来看一个生活中的「做菜」情景。「番茄炒蛋」是一道经典的家常菜，我们可以将烹饪它的过程归纳为这样的 5 个步骤：

- 准备材料：打蛋、洗净番茄切块；
- 单独炒鸡蛋：将鸡蛋炒至基本成型但保持嫩滑的状态，待用；
- 单独炒番茄：将番茄炒至变软，略开始出汁的状态；
- 合并一起炒，调味：将之前炒好的鸡蛋倒入，翻炒均匀，加入调味料；
- 出锅。

对于会做菜的读者，即使你从来没有炒过番茄炒蛋，看过这份菜谱之后，你也应该可以大差不差地将它做出来。然而，如果你是一位没有炒菜经验，甚至从来没有下过厨房的读者，这份步骤就略显笼统了。在这种情况下，我们可以先约定几个最简单、最基本的「操作」，如「切」「洗」「翻炒」等。这些操作十分机械化，可以在很短的时间内掌握它们。借助这些基础操作，我们的番茄炒蛋菜谱就可以改写为：

{{<columns>}}
- 准备材料：
  - **洗** *番茄* 3 个 → 得到「洗净的番茄」；
  - **切** *洗净的番茄* → 得到「番茄块」；
  - **打** *鸡蛋* 4 个 → 得到「鸡蛋液」；
- 单独炒鸡蛋：
  - **点火**；
  - **向锅中加入** *油* 20 mL；
  - **等待** 1 分钟；
  - **向锅中加入** *鸡蛋液*；
  - **翻炒** 2 分钟；
  - **熄火**；
  - **从锅中取出** *炒好的鸡蛋* → 得到「炒好的鸡蛋」；
<--->
- 单独炒番茄：
  - **点火**；
  - **向锅中加入** *油* 10 mL；
  - **等待** 40 秒；
  - **向锅中加入** *番茄块*；
  - **翻炒** 4 分钟；
- 合并一起炒：
  - **向锅中加入** *炒好的鸡蛋*；
  - **翻炒** 1 分钟；
  - **向锅中加入** *盐* 2 g；
  - **翻炒** 1 分钟；
  - **熄火**；
- 出锅：
  - **从锅中取出** *番茄炒蛋* → 得到「番茄炒蛋」。
{{</columns>}}

在这份新的详细版菜谱中，只包含 10 种基本操作，并且对每一步的操作，都用定量的方式来确定它们。同时，我们给整个做菜过程的「中间产物」都起了名字，例如「均匀的鸡蛋液」「番茄块」，这样可以最大程度地避免歧义。理论上，借助这样的一份新菜谱，即使是完全没有烹饪经验的人，也可以在简单培训后，照着它完成任务。

我们把这种通过组合利用少量、基础的操作，完成一项庞大、复杂的任务的思维，叫做「程序思维」。在计算机的世界里，硬件本身只能「理解」少量最基本的操作，如最基本的算术运算，以及「读取文件」「显示内容」等简单的对外交互。「程序」其实就是一份菜谱：像我们上面展示的那样，通过组合运用这些基本操作，实现各种各样的功能；而编程的过程，就是我们利用程序思维来编写这样的「菜谱」的过程。而这份番茄炒蛋的菜谱，本质上亦是一个「程序」，只不过执行它的硬件并非半导体芯片，而是我们人类。

在这个番茄炒蛋的程序中，我们将所有操作完全固定——从食材的量到翻炒的时间，都以具体的数字进行了规定。这样就降低了「硬件」的执行成本。然而，在现实生活中，起锅烧油所需要的时间可能与油的品质、气温、油量的多少等因素有关，而翻炒的时间也和食材的新鲜程度、切片时的厚度等挂钩。这种「固定一切」的思路，让整个程序过于死板，对环境没有适应能力。为此，我们再引入一种这样的操作：

- **如果** *番茄块* 还没有变软：
  - 再 **翻炒** 30 秒；
- **否则**：
  - 什么也不做。
  
如果说原来的程序是「做完一件事，就顺着做下一件事」的「一刀流」，那么在引入这种「如果」操作后，我们的程序长出了「分支」。在番茄比较生、气温比较低，或者水放少了的情况下，程序会进入「再翻炒 30 秒」这一支；而当番茄质地偏软、天气炎热，又或者油的品种不同时，程序就会选择什么也不做，然后继续向后运行。我们把原来的程序结构称为「顺序结构」，而这种引入「如果」的结构称为「分支结构」。

可是，分支结构只能实现「二选一」，通过嵌套多个分支也只能实现「三选一」「四选一」，程序能走出的道路终究是有限的。上面的例子让我们得以给不太好吃的番茄多炒 30 秒，可是如果 30 秒还是不够呢？进一步，在极端的情况下，再多 1 分钟也可能不够；而另一些时候，原本设定的 4 分钟翻炒可能已经多了一把「火」。分支结构在这样的情况下，「心有余而力不足」。为了解决这个问题，我们只能再采用一种新的操作：

- **当** *番茄块* 还没有变软 时：
  - 再 **翻炒** 30 秒。

乍一看，这个操作和刚刚提到的「如果」挺相似，但是它们的含义完全不同。这个操作是说，只要「番茄块还没有变软」，就一直重复不断地执行「翻炒 30 秒」这一步。只有某时刻，「番茄块还没有变软」不满足了，才能离开这个「轮回」，继续执行后面的流程。这样的结构称为「循环结构」，顾名思义，它的作用就是在一定的条件下，不断重复地做同一件事，直到这个条件不再成立。相较之下，「分支结构」也需要检查某个条件，但是即使条件满足，也只会选择某个分支执行一次。

> 分支结构和循环结构有明显的不同，但是，只要再引入一种操作，就能让分支结构「变」为循环结构。这个操作是什么呢？答案就是「跳转到第 x 步」，其中 x 是某步操作的编号。例如，下面的程序没有使用循环结构的「当」操作，却实现了和上面的程序完全一样的效果。
> 1. **如果** *番茄块* 已经变软：
>   - **跳转到** 第 4 步；
> 2. **翻炒** 30 秒；
> 3. **跳转到** 第 1 步；
> 4. 什么也不做。
>

事实上，我们可以将原本固定的 4 分钟翻炒直接替换为上面的循环。这样，我们的程序就会从一开始就根据番茄是否变软来控制翻炒的时间，实现了「具体问题具体分析」。进一步，我们还可以把循环体中的「30 秒」缩得更短，这样程序控制的精度就越高。

顺序、分支和循环结构是程序的三种基本控制结构——事实上，**只需要**这三种结构，世间一切复杂之事，就都可以用程序思维分解为基础操作的组合。你不妨现在思考一下身边各种各样的事：小到日常生活中的鸡毛蒜皮，大到社会运行的底层原理，一切都可以归约成这三种结构组合之下的基本操作。这就是程序思维的力量，也是今天的数字世界能够诞生的重要基石。

### 编程语言

在上一小节中，我们设计了一个菜谱「程序」。对于这个程序的每一步，我们都使用完整的中文句子来描述它的含义。然而，世界上的语言有成千上万种。我们大可以使用不同的语言来描述这份菜谱——只要保持每一步的含义不变，那么整个程序的本质和功能就没有改变。例如，我们将原有菜谱的第二段「单独炒鸡蛋」译成英语，并不会改变做这道菜的流程。

- Scramble Eggs Alone
  - Light the stove;
  - Add 40 mL of oil to the pot;
  - Wait for 40 seconds;
  - Scramble for 3 minutes;
  - Turn off the stove;
  - Set scrambled eggs aside.

诸如中文、英语、法语这样的语言，是我们人与人之间沟通的「桥梁」，而借助这样的桥梁，我们才得以用菜谱来指导他人完成烹饪。而在真正的计算机程序的世界里，人们亦设计了无数种不同的「语言」，它们是我们人类和「机器」沟通的桥梁。

（这一节感觉不好写，先放这）

### 算法

## 0 与 1 之间的舞蹈

至此，我们已经明白，通过各种各样的编程语言，借助程序思维，人们得以将需要完成的工作编写为「程序」；而通过对算法的研究，又能在极大程度上提升程序的效率，从而更有效地解决问题。然而，我们所认识的「程序」，与冷冰冰的芯片、导线、电路所构成的计算机硬件之间，依然还有着一层厚厚的「隔阂」。程序所奏响的思维之歌，是如何化为 0 与 1 之间的舞蹈的？下面，就由我们为你一一讲述。

### 从程序到指令

在 [万言皆数——字符与编码规则]({{<ref "characters-and-encodings.md">}}) 一章中我们提到，计算机中的一切信息都由电路承载；具体地说，每个信息都是由若干位 0 和 1 这样的二进制数字所组成，反映在电路上，就是「有电」「无电」之间的排列组合。为了实现程序在硬件上运行，自然而然地，我们首先就需要寻找「程序」在硬件上的表达方式。具体来说，是将程序的每一步用 0 和 1 来表达的方式。

在本章的第一节，我们构想了一个「番茄炒蛋」的程序，不过那时我们认为这个程序的「硬件」就是我们人类。现在，我们想要让一台炒菜机器「你缺饭课一号」也能执行这份菜谱程序。「你缺饭课一号」并不能看懂中文、英文这样的人类语言，它所能做的，就是不断地读取某处并排的 8 根导线上的信号（即 8 位二进制数），然后根据这组信号的值，执行一个简单的动作。假设「你缺饭课一号」的部分设计如下：

- 机器一共有 4 个用来装食材的碗，可以在烹饪过程中使用。
- 机器不断地读取一个 8 位的信号，并按照下面的规则选择动作：

  | 信号 | 功能 |
  | :--: | -- |
  |`0001xxyy`|洗一份食材。`xx` 决定食材的种类：`00` 代表番茄、`01` 代表青椒……<br/>`yy` 表示洗完之后的食材加在哪个碗里，一共有 `00` 至 `11` 四个碗可以使用。<br/>例如，信号 `00010000` 能控制机器洗一份番茄放到第 0 号碗里。|
  |`001000yy`|打鸡蛋。`yy` 决定打好的蛋放在哪个碗里。|


  - `001100yy` → 切菜。将 `yy` 号碗中的食材全部切块。
  - `01000xxx` → 给灶台点火，并向锅中加入的油。
    其中，油的量为 {{<katex>}}10\times\overline{\text{xxx}}_\text{B}{{</katex>}} mL 
    例如，`01000100` 对应的 `xxx` 是 `100`，这组信号会让机器点火后加入 {{<katex>}}10\times4=40{{</katex>}} mL 的油。
  - `010010yy` → 向锅中倒入碗 `yy` 中的全部内容。
  - `1000xxxx` → 在锅中翻炒 {{<katex>}}10\times\bar{xxxx}_2{{</katex>}} 秒。
  - `1100xxxx` → 等待 {{<katex>}}10\times\bar{xxxx}_2{{</katex>}} 秒。
  - `1110xxxx` → 向锅中加入 `xxxx` g 的盐。例如，`11100101` 对应的 `xxx` 是 `101`，这组信号会让机器向锅中加入 5 g 盐。
  - `111100yy` → 将锅中的所有内容倒到 `yy` 号碗中。
  - `11111111` → 熄灭灶台。

那么，我们可以依次给这台机器发送下面的 24 条信号，机器就能按照菜谱精准地完成一道番茄炒蛋。

1. `00010000`（洗一个番茄放到 0 号碗中，我们要重复发送这个信号 3 次，因为我们需要 3 个番茄）
2. `00010000`（洗一个番茄放到 0 号碗中）
3. `00010000`（洗一个番茄放到 0 号碗中）
4. `00100001`（打一个鸡蛋放到 1 号碗中。为了实现打 4 个鸡蛋，这条得重复 4 次）
5. `00100001`（打一个鸡蛋放到 1 号碗中）
6. `00100001`（打一个鸡蛋放到 1 号碗中）
7. `00100001`（打一个鸡蛋放到 1 号碗中）
8. `00110000`（将 0 号碗中的食材全部切块，即将番茄全部切块）
9. `01000010`（点火，向锅中加入 20 mL 的油）
10. `11000110`（等待 60 秒，即 1 分钟）
11. `11110001`（将 1 号碗中的鸡蛋液倒入锅中）
12. `10001100`（翻炒 120 秒，即 2 分钟）
13. `11111111`（熄火）
14. `11110010`（将炒好的鸡蛋倒到 2 号碗中，备用）
15. `01000001`（点火，向锅中加入 10 mL 的油）
16. `11110000`（将 0 号碗中的番茄块倒入锅中）
17. `10001100`（翻炒 120 秒，即 2 分钟）
18. `10001100`（翻炒 120 秒，即 2 分钟，这样才能一共翻炒 4 分钟（为什么？））
19. `11110010`（将 2 号碗中炒好的鸡蛋倒入锅中）
20. `10000110`（翻炒 60 秒，即 1 分钟）
21. `11100010`（向锅中加入 2 g 盐）
22. `10000110`（翻炒 60 秒，即 1 分钟）
23. `11111111`（熄火）
24. `11110011`（将炒好的菜倒入 3 号碗中）

最终，我们可以在 3 号碗中得到一份 ~~美味的~~ 番茄炒蛋。如果我们把这 24 条信号记录在某种「你缺饭课一号」可以直接读取的设备上，并让「你缺饭课一号」能够自动从这个设备中一条一条读取信号并执行，不就实现了整个过程的自动化运行了吗？

> 这个「设备」对应到计算机上就是内存。诶——你是不是想到硬盘上去啦？的确，我们的电脑程序都是安装在硬盘上的（如果不知道的话，请重修 [认识你的电脑]({{<ref "computer-and-its-components.md">}})）。但事实上，你双击启动一个程序时，机器会首先把它加载到内存里，然后再从内存中一条一条取出指令（见下文）运行。

我们把这样一条一条的信号称为「指令」（instruction），它是机器能够直接执行的最小单元。可以想象，要让一个程序在机器上运行，就需要把程序转变成一条条指令，并将这些指令按顺序装载进机器。我们将一个程序所对应的指令序列称为「机器代码」。

回到现实生活中的计算机。显然，计算机并不能用来炒菜，它的本职工作就是「计算」。因此，在计算机的指令世界中，肯定不会有什么「洗菜」「翻炒」这样的指令；相反，在计算机中，各种各样的指令可以分成如下的几类：

- 数据传输指令：用来将数据在计算机内部各种地方传递。
- 算术与逻辑运算指令：用来执行各种各样的计算，包括算术运算和逻辑运算。


### 指令集的明争暗斗

### 体系结构与应用生态

## 编程能为你带来什么

## 练习

