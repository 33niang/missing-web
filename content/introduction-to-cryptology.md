---
title: 以密码之剑护网安之盾
type: docs
# draft: true
---

# 以密码之剑护网安之盾

{{<hint danger>}}
🚧本章仍在施工中，内容并不完整且会发生变化，仅供先行阅读参考。
{{</hint>}}

{{< hint info >}}
在网络越来越发达的今天，网络安全早已成为国家安全的头等大事之一。但这份「安全」，要靠人类不断发展与精进的密码学来守护。这一章，我们来走进密码学的世界，探寻数字与文字间的舞蹈，以及密码如何守护网络世界的安全。读完本章，你应该有了下面这些问题的答案：

- 为什么网络世界中危机四伏？
- 什么是「密码」，它和我们平常使用的「登录密码」有何联系？
- 从古至今，世上有哪些有代表性的密码？
- 「HTTPS」是什么？为什么有时浏览器会提示「网站不安全」？
- 当今的密码如何保证我们的信息在网络中完整与安全？

{{< /hint >}}

今天的世界已经离不开网络，从我们的日常生活到政府各项事务的管理，从企业的高效运转到顶尖的科学技术，网络已经成为了这一切的基石。可是你是否想过，这个网络世界其实「危机四伏」？我们在网络上传输的信息，可以很轻易地遭到拦截和篡改；在企业与企业之间，甚至国与国之间，网络已经成为「没有硝烟的战场」。这样的环境之下，密码学技术帮助人们保护信息的安全，而以密码学为武器，人们构建起了网络安全的完整体系。

## 危机四伏的网络世界

网络世界之所以「危机四伏」，从某种意义上来说，和当今互联网的底层技术——「分组交换」——脱不了干系。

我们说网络连接了世界的每一个角落，但这么多角落都依靠「点对点」的直接连接显然不太现实。事实上，网络之所以称为「网络」，正是因为它如同我们不时见到的蜘蛛网一样，由许多「结点」张成，信息在结点之间进行「转发」。今天，我们可以使用网络与远在地球另一端的朋友交流，并不是因为我们之间用一根无比长的网线牵着，而是因为我们之间有许许多多相互连接的结点，它们在我们之间搭成了一条「通路」。

为了提升信息在结点之间传输的效率，网络会将我们需要发送的数据「切」成许多一定长度的小片段，这些片段就像一个个快递包裹一样，流入一个个结点。每个结点如同快递的转运中心，会根据片段上标记的「目的地」信息，将片段转发给去往目的地的下一个结点。就这样，经过一次次转发，我们的数据片段最后都会抵达终点，并重新组装为完整的数据。这种传输方式称为「分组交换」，它奠定了互联网的传输基础。

然而，看似十分完美的过程，实际上充满危机。在网络上传输的数据可以很轻易地被截获，甚至直接修改也不是什么难事。攻击者只要攻击、控制了网络中的一个结点，所有经过它的数据片段都一览无余。如此一来，攻击者可以随意篡改数据片段的内容，使得最终发送到目的地的数据大相径庭；或者将数据「拦下」，让目的地收到不完整的信息，甚至完全收不到数据。攻击者甚至可以伪造我们的名字，以我们的名义发送伪造的信息，从而造成具有破坏性的后果。

如果将数据加密，这些问题就能得到一定程度的解决。加密后的信息即使被截获，攻击者也无法得知其中内容，更无从谈及篡改和伪造。密码技术的发展，让高效的加密成为了可能。接下来，让我们推开密码世界的大门，领略今天的「密码之剑」如何铸成。

## 蓬勃发展的密码学

### 人类的「传统艺能」

<p style="font-size: 6px; font-weight: 100; color: lightgray; text-align-last:justify; margin: -4px">S t e g a n o g r a p h y</p>
几千年来，人类的交锋见证了密码学的发展，从古代战场间的传令、军中机要情报的转移、能工巧匠家里的祖传秘方，到如今网络世界的信息流转……种种危机四伏的场景，如何让这些重要信息不被不相关的人员所知晓，便是这种「仅有我认识」的文字技艺的用武之地了。跨越几千年的时间长河，我们从头来看「密码」的力量如何铸就诸多信息的安全无虞。

让我们首先把目光投向密码学的孪生兄弟——「隐写术」（steganography）。「隐写术」，顾名思义，就是把重要信息「隐藏着写下来」，让读它的人基本不会注意到重要信息的手段。虽然它不算一种密码，但在「使信息对不知道的人来说很难看出来」这方面，它和密码是一样的。

古罗马的古典诗人奥维德就曾记录过用新鲜牛奶写信的隐写术——这样写在纸上的字很快就会消失不见，但是如果点燃字迹的一角，就可以将字迹显现出来。除了牛奶外，一些植物汁液、明矾、果汁等也被用作隐形墨水。另外一些隐写术则和今天学生的小抄有些类似——将信息写在树叶上、衣服里或是身体上，再运用多种方法进行遮掩。还有一些，隐藏在文字的字里行间，例如藏头诗，或将句子中每个单词的第一个字母连字成句……可无论如何，只要你能看到隐藏的信息，你就能读懂它，这也是隐写术的特点——明文隐写。

虽然一直以来，隐写术都是非常基础的信息隐藏技术，但在现代的电子显示设备上，为了解谜游戏的谜题，或为了实现某些特殊的效果，隐写术焕发了第二春。譬如本节的开头就藏着小小的一行「Steganography」，除此之外，信息文本可以是透明的，也可以藏在网页背后的代码之中……<span style="color: rgba(0,0,0,0)">比如这</span>

与隐写术相比，密码学（cryptography）的目标，则是将内容「变换」，使之变成常人看不懂的模样。这样的技术称为「密码」（cipher），而对应的学科称为「密码学」。公元前 5 世纪，古代的斯巴达人使用过一种叫做「密码棒」（Scytale）的器械，就是一根上面缠绕有羊皮纸条儿的木棍。人们把信息竖着写在羊皮纸条儿上，写完后从木棍上取下，原本的字母顺序就被打乱，难以再看出原本的信息。需要阅读时，只需取一根同样规格的木棍，将羊皮纸重新缠绕即可。这种密码棒是人类历史上已知的最早的密码器械。

![密码棒](introduction-to-cryptology/Scytale.png#center)

> 所以「密码」一词指的是将信息进行变换以进行保密的技术。而我们在生活中经常说的 **「登录密码」「开机密码」，虽然也叫「密码」，但是含义并不相同，它们的学名叫「口令」**。

古罗马的凯撒大帝使用过这样一种方法来保护重要的军事信息：将每个字母向后移动 3 位。如下图所示，左侧是一个加密轮盘，外圈的明文与内圈的密文一一对应，当前正对着明文 A 的是 3，也就是偏移 3 位的状态。将右侧的明文情报按左侧的对应关系转换过来，就得到了看不懂的密文。

![凯撒密码](introduction-to-cryptology/CaesarCipher.png)

若不知道这种方式的具体细节——甚至，即使知道它采用了移动字母的方式，如果不知道具体的偏移数字，他人就很难从后面这个句子猜出原本的内容。这种密码被称为「凯撒密码」。事实上，凯撒密码不止局限于「3」这一个偏移量，0 到 25，你可以选择你喜欢的，只要把轮盘转到对应的位置就好。

在这些例子中，原始信息称为「明文」，经过处理后，难以理解的信息被称为「密文」。将明文转换为密文的过程称为「加密」，而反过来就是「解密」。为了完成这两个过程，我们需要用到额外信息——「密钥」，它就像一把钥匙，加密与解密都是需要它来打开的门扉。例如，对于密码棒来说，秘钥是密码棒的尺寸；对于凯撒密码，密钥就是它的偏移量——3 这个数字。

然而实际上凯撒密码非常容易破解，即便你不知道密码的偏移量，英文就那么 26 个字母，一个个试都能试出正确的秘钥。所以，人们不再局限于往一个方向偏移，而发明了「字母替换密码」。字母替换密码就相当于重排字母表，将每个字母替换成另一个字母，例如：

```text
原文：ABCDEFGHIJKLMNOPQRSTUVWXYZ
密文：QWERTYUIOPASDFGHJKLZXCVBNM
```

这样一来，「MISSING」一词加密之后就变成了「DOLLOFU」。相比凯撒密码，字母替换密码更隐藏了字母之间的相对位置关系，而高达{{<katex>}}26!{{</katex>}}种加密情况也使得它更难被暴力破解。然而，人们统计了大量文本，发现英语这样的字母语言中，每个字母在文本里出现的频率基本上是个定值。譬如 E 与 T，就是在英语中出现频率最大的两个字母。这就是「频率分析」的威力，靠这样的分析，人们就可以确定字母间的对应关系，从而破解字母替换密码。

于是，又从凯撒密码出发，人们发明了一种有趣的加密方式——维吉尼亚密码。在凯撒密码中，每个字母前后推动的距离是固定的，而维吉尼亚密码通过构建一个「密码表」，将这一距离动态化，增加了破译的难度。

维吉尼亚密码的「密码表」靠字母建立。在凯撒密码中，每一个特定的偏移量下，A 都会对应不同的字母，那么反过来，可以用与 A 对应的字母来指示偏移量，例如 D 就代表偏移量为 3。下图展示了用「WINDY」加密「MISSING」的过程，可见，每一次的偏移量都在变化，这样一来，若不知道密钥，就很难破解密文。

![维吉尼亚密码](introduction-to-cryptology/VigenèreCipher.png)

密码学伴随着人们保密意识的产生而诞生，然而直到 20 世纪 50 年代，密码学的本质都没有什么变化。各种加密方式都可以归类为「代换」和「置换」两种变换或它们的组合：「代换」指的是「用一种字母替代另一种字母」，而「置换」指的是「变更不同字母的位置」。上文提到的密码棒就是一种置换密码，而凯撒密码及其衍生版本则是代换密码。

在这一时期，密码的安全性，来源于代换和置换的精巧设计；而这样的设计，或基于经验，或基于直觉。因此，此时的密码学更像是一门「艺术」——比起严格的论证，它更侧重人类头脑中的灵光一闪。同时，这些密码大多可以通过频率分析的方法破解。如今，我们把这整个时期的密码学都称为「古典密码学」，而相关的密码则称为「古典密码」。

1949 年，美国数学家、工程师香农的《保密系统通信理论》（*Communication Theory of Secrecy Systems*）从数学和信息论的角度阐明了关于密码系统的分析、评价和设计的科学思想，提出了有关密码学的完整数学模型。简单来说，这篇论文用数学的语言，定量地描述了密码的「安全性」，以及与其相关的一系列概念，如密钥的复杂度、加密的复杂性等等。它让密码从一门基于感性构造、精巧设计的「艺术」，开始走向基于理论分析、实验验证的「科学」。

自此，密码学的发展有了理论的指导，密码学开始从人类的「传统艺能」向科学转变，近代密码学的序幕就此拉开。

### 对称密码的发展

#### 一把钥匙开一把锁

第二次世界大战期间，纳粹德国使用一种被称为「恩尼格玛」（Enigma，意为「谜」）的密码机来加密军事通讯。这种密码机形如一台打字机，只不过它没法装纸，也不能在纸上打字；相反，它有一个由 26 盏小灯泡组成的显示板，排布就如下方的键盘一般。此外，在机器上方，它还装有几个印有字母的机械转盘（称为转子）。下方左侧就是一种常见型号的恩尼格玛密码机的示意图。当使用者在键盘上击键时，某个不同字母[^enigma]对应的小灯就会亮起——这便是对应字母加密后的密文。

[^enigma]: 没错，这正是恩尼格玛密码机的特点之一：加密后的字母绝不与原始字母相同。你可以在阅读下面的介绍后思考一下这是为什么。

![ENIGMA](introduction-to-cryptology/Enigma.png#center)

上方右图展示了恩尼格玛密码机大致的工作原理。每 <u>➊ 按下一个键</u>，<u>➋ 转子就转动一格</u>。转子之间有联动机构——当一个转子转完一圈后，它左边的转子也会转一格。同时，按下的键发出一个电信号，并首先被传到「接线板」，在这里分布着对接到不同字母的插孔，使用者可以 <u>➌ 插上一些「跳线」，将信号在连接的字母间对换</u>。紧接着，<u>➍ 电信号进入第一个转子</u>。不同的转子内部会按各自的规则替换字母，使用者可以按需选用不同型号的转子。<u>➎ 信号依次流过三个转子，并在折返后再反向流回去。</u>此时，电信号代表的字母已经和原来按下的字母相去甚远了。最后，<u>➏ 信号再被送入接线板</u>进行 <u>➐ 最后一次替换</u>，然后 <u>➑ 点亮对应字母的灯泡</u>。

> 上节介绍了「明文」「密文」「密钥」的概念，那么恩尼格玛密码机的明文、密文和密钥是什么？
 
在这样的一整个流程中，字母一共经过了 8 次替换，而且由于转子随每次击键而旋转，这种替换关系每输入一个字母就会变化，使得字母之间的对应关系变得极其复杂，最终的密文与原文看起来毫无联系。但解密却很简单，只需要在另一台相同型号的密码机上安装相同的转盘，调整到相同的起始位置，并以相同方式连接跳线，输入密文，即可打出原始的明文。

二战前期，德军在战场上节节胜利，一定程度上依靠了恩尼格玛密码机强力的加密效果，让他们顺利隐藏自己的情报与动向。然而，盟军方面却为破解恩尼格玛密码机付出了不少努力。

事实上早在 20 世纪 20 年代，德国已经开始使用恩尼格玛密码机。1927 年，英国方面买了一台商用恩尼格玛密码机，这种机子没有接线板。花了十年终于成功破解，但可惜没法用在军用机上。而同期波兰的研究者依靠对德语的了解与一些间谍活动，初步破解了三转子的军用密码机。二战期间，盟军基于这些成果，外加一些德军的疏漏，才成功破解恩尼格玛密码机，并逐步扭转战局。

> 据说在热门网络游戏《第五人格》中，玩家需要破译的「密码机」，设计原型就是恩尼格玛密码机。

无论是凯撒密码还是恩尼格玛密码机，它们都有一个共同的特征：**加密和解密过程使用相同的密钥**。解密凯撒密码，只需加密时使用的偏移量即可；而对于恩尼格玛密码机，则需要知道加密时使用的转子型号、转子起始位置以及跳线连接情况。这样的密码被称为「对称密码」，如同现实生活中的钥匙和锁一样，我们使用同样的钥匙来上锁和开锁。对称密码是最基本的一种密码形式，它符合我们对「加密」这件事的直觉，因此当密码学从古典时期迈向近代时，人们首先研究的，便是如何设计出安全、高效的对称密码。

#### 混淆与扩散

前文我们提到，古典密码的设计模式，总可以分成「代换」和「置换」两类。前者替换内容，后者更改位置。在近代密码学中，人们从信息论的角度对这两类方式进行了概括和发展，代换与置换法随之进化为「混淆」和「扩散」。

- 「混淆」旨在掩盖密文和明文之间的对应关系，最简单的方式是代换。增强混淆效果则需要设计更加复杂的变换方式。恩尼格玛密码机通过多个旋转转盘改变字母映射，其实亦是一种混淆。
- 「扩散」的目的是将单个字母加密所带来的影响扩大——譬如，加密一个字母，可能会改变密文中多个字母的表示。置换是扩散的最简单方式，但能力非常有限——只能影响某处单单一个字母。而现如今使用的各种对称加密算法，都能做到「原文改变一点点，密文改变一大片」。

优秀的密码算法，就是科学地结合混淆和扩散，实现最大的安全性。顺着这样的思路，我们介绍两款在密码学历史上具有重要意义的对称加密算法：曾经风光无限但已寿终正寝的 DES，以及今天正在广泛使用的 AES。

#### 数据加密标准（DES）

20 世纪 70 年代，随着美国政府开始重视计算机安全问题，美国国家标准局（NBS，现为美国国家标准与技术研究院 NIST）开始征集用于政府内信息加密的算法。最终，IBM 公司提出的一套算法得到采用，NBS 为它赋予「数据加密标准」（Data Encryption Standard，简称 DES）的名字并正式公布。DES 算法采用了一种「分组加密」的思路——将明文先切割成固定 64 位长的块，再逐块加密，块与块之间的加密可以互相影响，这些块的密文最终合成为一条完整的密文。解密时，只需反向切割密文，再逐块解密即可。

> 在本章后续的介绍中，「位」均指「二进制位」，比如「64 位的明文」指明文由 64 位二进制数（即「比特（bit）」）组成。

而 DES 对每一块加密时，都会使用 56 位长度的密钥来**循环进行 16 次包含代换和置换的操作**。其中的代换部分，DES 使用一套预先设计好的代换表——「S 盒」施行。例如，使用如下的 S 盒时，对于一个输入数据 46，我们先将它转换为十六进制 `2E`，再寻找第 `2` 行第 `E` 列的值，就能得到代换后的结果 `B`，即 11。DES 一共有 8 个这样的 S 盒： {{<katex>}}S_1{{</katex>}} 至 {{<katex>}}S_8{{</katex>}}，它们互不相同，每个都是经过特定设计得到的，可以在加密过程中引入复杂性来防止被轻易破解。

|     | _0  | _1  | _2  | _3 | _4 | _5 | _6 | _7 | _8 | _9 | _A | _B | _C | _D | _E | _F |
| --- | --- | --- | --- |--- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| **0_**   | E   | 0   | 4   | F   | D   | 7   | 1   | 4   | 2   | E   | F   | 2   | B   | D   | 8   | 1   |
| **1_**   | 3   | A   | A   | 6   | 6   | C   | C   | B   | 5   | 9   | 9   | 5   | 0   | 3   | 7   | 8   |
| **2_**   | 4   | F   | 1   | C   | E   | 8   | 8   | 2   | D   | 4   | 6   | 9   | 2   | 1   | B   | 7   |
| **3_**   | F   | 5   | C   | B   | 9   | 3   | 7   | E   | 3   | A   | A   | 0   | 5   | 6   | 0   | D   |

> 想知道 DES 的具体过程？受限于篇幅和本文的定位，我们在此处不作过多介绍，你可以自己上网搜索。
>

1975 年，DES 正式对外公布，并在 1976 年被定为美国联邦标准。DES 的提出，在密码学历史上具有里程碑式的意义。DES 公开后，没过几年就成为了世界上使用最为广泛的加密算法：美国政府使用 DES 存储重要信息，大型企业使用 DES 保护商业秘密，美国银行业将 DES 作为批发银行业标准……另一方面，DES 所使用的分组加密思想、费斯妥结构和密钥扩展等思路，启发着无数后继加密算法的研究。

然而，有关 DES 算法本身的争论从它诞生开始就没有停息。围绕 DES 算法本身，争论的焦点有两个，其一便是 56 位的密钥是否足够安全。任何密码都存在通过穷举所有可能的密钥来破解的可能，这就是「暴力破解」。而实际破解的难度会随着算力的发展快速下降：在 1977 年——也就是 DES 成为联邦标准的次年——就有学者构想了一台造价 2000 万美元，可以在 1 天内暴力破解 DES 密码的机器。到了 1993 年，同类机器的理论成本降到了 100 万美元，时间缩短到 7 小时。而在 1998 年，一台造价只有 25 万美元的破解机器被实际造出，从此破解 DES 成为事实上的可能。除了暴力破解外，一系列更高效的破解算法亦于上世纪末出现，它们让 DES 从「安全无比」的神坛上跌落，向人们昭示着密钥长度的重要性。

而有关 DES 的另一个争论，便是其神秘的 S 盒设计。我们刚才提到，DES 一共使用了 8 个 S 盒执行代换，而它们是人为设计并公开给大众使用的——那么，为什么这些 S 盒要这样设计呢？它们是否真的足够「安全」？尽管 S 盒的设计声称安全无比，并能防御多种破解方式，但是这些设计是否存在不为人知的甚至是**刻意留下的**漏洞呢？由于 IBM 并没有完全公开 S 盒的设计方法，这些问题变成了悬在人们头上的利剑，而执剑人则隐藏在黑暗之中。人们开始思考，能否让 S 盒的构造方式变得透明，同时仍然保持足够的安全。

基于各种安全原因，1999 年，DES 被要求「只能在遗留系统中使用」，新的系统必须使用 DES 的升级版——三重 DES（Triple DES，简称 TDES 或 3DES），即利用两个密钥进行 3 次 DES 加密。然而这只是「换汤不换药，治标不治本」罢了。2005 年，美国官方不再使用 3DES，但 NIST 仍然保留了 3DES 作为可选标准。2018 年，NIST「退役」3DES，从此 3DES 只能在老旧的系统中使用，各种软件纷纷开始移除对 3DES 的支持。

2023 年 6 月，NIST 宣布将于 2024 年 1 月 1 日起，正式撤销有关 3DES 的使用建议（下图）。这标志着美国完全抛弃 3DES，而各地的软件厂商亦已用更安全的加密算法完全替代它。属于 DES 的时代画上了句号，它的后继者——高级加密标准（Advanced Encryption Standard，简称 AES）则在今天继续守护着我们的安全。

![NIST 退役 3DES 的公告](introduction-to-cryptology/NIST_announcement.png#center)

#### 高级加密标准（AES）

上世纪末，DES 逐渐被证明不再安全。人们除了「亡羊补牢」式地急忙提出 3DES 算法外，亦开始寻找新的更安全的加密算法。NIST 开始征集新的加密算法，在经过数年的甄选后，由比利时密码学家 Joan Daemen 和 Vincent Rijmen 所设计的一款算法最终脱颖而出，于 2001 年被命名为「高级加密标准」（AES）并公布。自此，属于 DES 和 3DES 的时代开始落幕，而直到今天，AES 仍然是事实上最被广泛使用的对称加密算法，并且依然有着无与伦比的安全性。

和 DES 一样，AES 也是一种分组密码，不过分组长度为 128 位。AES 同样采用了代换置换结合的方式完成一轮加密操作，亦通过多次的循环来确保安全性。不过，AES 使用的结构与 DES 有所不同，密钥长度也不一样：AES 可以选择 128 位、192 位和 256 位三种不同长度的密钥，远远安全于 DES 的 56 位。同时，相比于 DES 使用人工设计的 S 盒，AES 在执行代换操作时的 S 盒是使用数学方法构造的，因此其不存在被留下刻意漏洞的空间，同时又能保证代换具有足够的安全性。

> AES 的 S 盒在本质上，是在有限域 {{<katex>}}GF(2^8){{</katex>}} 上针对素多项式 {{<katex>}}m(x) = x^8 + x^4 + x^3 + x + 1{{</katex>}} 进行的求逆运算。
>

AES 优秀的算法设计使其保持着足够的安全性。直到今天，人们仍然没有发现实用的针对 AES 的破解方法。自 2002 年 AES 被 NIST 采用为标准以来，AES 已经成为了最流行的对加密算法，在我们的生活中几乎无处不在。例如，你正在浏览的《你缺计课》网站本身，就是使用 AES 加密后安全地传输到你的手机或电脑上的（作为 HTTPS 技术的一部分；在本章稍后我们会提到）；在我们的手机、电脑内部，操作系统亦大量使用 AES 来加密存储敏感数据，以防止设备失窃后的隐私泄露。

### 非对称密码的兴起

#### 令人头疼的密钥交换

对称密码的不断发展，让数字时代资料的保密存储成为了现实。然而，无论是 DES、3DES 还是 AES，这些对称密码在用于数据传输时都有一个问题：加密和解密用的密钥，如何安全地在双方之间共享呢？

或许你会说，只要提前将密钥发送给对方就行了。但是请别忘记，我们之所以要进行加密的通信，正是因为通信的环境不安全——在本章开头我们就提到，网络世界「危机四伏」。所以，提前将密钥发送给对方，就有可能造成非常严重的后果——我们的「钥匙」可能被恶意地拦截、伪造甚至调包，让之后的一切加密都形同虚设。你也许还会想到，能否通过物理上安全的方式——比如，线下碰个面——来提前沟通密钥呢？对于一些情况这样做似乎可行，但如果通信双方是未曾谋面的陌生人，恐怕就不太方便了。在这样的背景之下，寻找一种**不需要提前共享相同密钥，就能实现加密通信**的方式，成为了摆在我们面前的现实问题。

我们想象一个现实的场景。在那交通还不发达的古代，小明和小红相隔千里，现在，小明（发信方）要将一则非常重要的机密信息用鸡毛信的方式传递给小红（收信方）。由于路途漫长，信件在传递过程中几易其手，很难保证不被好事之人窥探。为了保证信息的安全，他们想到了一个这样的方法：

- 首先，小红制作一个带锁的信封。这种锁和我们日常生活中用的门锁类似，锁上后需要用钥匙打开，但是开锁后用力一扣就能锁上，无需钥匙。
- 接着，小红先把这个信封上的锁打开，将信封寄给小明，但钥匙留在自己手上。
- 小明收到信封之后，把需要寄出的机要信息装进信封，用力一扣——现在，信封被锁上，除了小红以外的任何人都无法打开它了。
- 最后，小明把这个装好信件的上锁信封寄给小红。小红收到后，用自己手里的钥匙将信封打开，取出信息。

下图展示了这个过程。

![远古公钥加密](introduction-to-cryptology/Ancient_public_key_encryption.png#center)

在这样的过程中，通信双方之间并没有提前交换过任何「钥匙」，只要锁本身足够安全，就可以确保只有小红自己能取出信件，而负责发信的小明并不接触钥匙。当小红需要回复一则消息给小明时，也只需要先让小明也做一个同类的信封，再对称地进行一篇同样的流程即可。

我们可以看到，在这套不用提前交换钥匙就能实现双向保密的过程中，「带锁的信封」是关键。这个带锁的信封具有一个重要的「非对称」性质：上锁只需要用力扣上，而开锁需要使用钥匙。将这个过程类比到加密、解密的过程，我们自然而然地想到——如果能设计一种加密和解密使用两把不同密钥的加密算法，不就可以完美地解决本节开头提到的那个问题了吗？

假设现在有一种加密算法，使用密钥 P 将明文加密，但是加密后的内容要使用密钥 S 来解开。小明需要向小红安全地发送一则消息，只需要先让小红准备一对这样的 P 和 S。小红将密钥 S 保留在手中，将密钥 P 发送给小明——不必考虑安全与否，甚至，小红直接将密钥 P 公之于天下也行。小明看到后，将手中的消息使用小红的密钥 P 加密，再将密文直接发送给小红。现在，只有小红手里的密钥 S 能解开这则密文，而密钥 S 始终留在小红自己的手里。信息被安全地传输，而用于解密的密钥全程没有被交换过。

由于密钥 P 是被小红主动公开的，因此我们称为「公钥」；密钥 S 始终留在小红自己手里，我们称为「私钥」。公钥用于将明文加密成密文，而私钥用于解密。小红持有的公钥和私钥，只适用于别人向她发送消息；因此，通信各方都需要准备一对自己的公钥和私钥，并各自将公钥公开给他人。这样的加密方式被称为「公钥密码」；又由于公钥、私钥的非对称性，也被称为「非对称密码」。

这个系统看起来完美得不得了，只不过有一个小小的问题——这样神奇的加密算法真的能存在吗？还真别说，真就给人们找出来几个。

#### 单向函数、陷门与公钥加密

先来做两个数学题：

1. 计算 {{<katex>}}97\times 47{{</katex>}} 的值；
2. 已知两个质数 {{<katex>}}p{{</katex>}} 和 {{<katex>}}q{{</katex>}} 满足 {{<katex>}}p\times q=4559{{</katex>}}，求 {{<katex>}}p{{</katex>}} 和 {{<katex>}}q{{</katex>}}。

如果你真去算了两道题的结果，就会发现它们互为答案，并且各自是对方唯一的答案。然而，做这两道题的难度，则完全不在一个数量级：对于第一题，只需要简单的竖式乘法就能算出来，或许你还可以直接口算甚至心算；但对于第二题，除了从 2 开始逐个质数地尝试，没有什么好方法了。可以想象，如果这样的 {{<katex>}}p{{</katex>}} 和 {{<katex>}}q{{</katex>}} 大到一定程度，就能让计算机也几乎解不出问题 2。同时，问题 1 的乘法计算依然能高效的解决。如果把这样的运算视为函数，它们被称为「单向函数」。顾名思义，「单向」说明这样的函数正着算很容易，倒着算很难。

现在，如果我们在问题 2 的基础上提供一点儿提示，让它变成如下的问题 3:

3. 已知两个质数 {{<katex>}}p=97{{</katex>}} 和 {{<katex>}}q{{</katex>}} 满足 {{<katex>}}p\times q=4559{{</katex>}}，求 {{<katex>}}q{{</katex>}}。

问题就变得十分简单，只需要进行一次除法运算，就能得到需要的结果。额外提供的这个提示信息（{{<katex>}}p=97{{</katex>}}）并不是完整的最终答案，但在提供这个信息后，通向答案的路就突然从荆棘满地变得顺风顺水。像问题 2 这样的单向函数被称为「陷门函数」，它们在反向计算的道路仿佛有许多沆沆洼洼的「陷」，使得反向计算极为困难；但如果用一些秘密信息将这样的「陷」填上，就能让计算顺利进行。

我们生活中常用的门锁就是一个陷门函数的例子。在开锁状态下，我们可以用力一扣就将它上锁——这如同陷门函数的正向过程。而如果使用蛮力，就很难将锁打开——这是陷门函数的反向过程。「钥匙」则是用来填充陷门的秘密信息，将钥匙插入锁芯，门锁就能轻松打开。

钥匙、锁……等等！这不就是在我们在上一节想象的那个小明和小红的例子中用到的东西吗！自然而然地，我们马上联想到，陷门函数这样的性质，可以作为设计公钥密码的基础：用公钥加密的过程，就是陷门函数的正向过程，亦是上锁的过程；用私钥解密的过程，就是陷门函数的反向过程，对应开锁的过程。上世纪 70 年代，在这样的思想的启发下，公钥加密经历了从提出到实现的飞跃，密码学从此翻开了新的一页，进入了现代时期。

#### 大数分解困难问题与 RSA 加密算法

上一小节中，我们给出了一个非常简单的单向函数——质数乘法。虽然看着就不怎么靠谱，但当两个乘数非常大时，在目前的技术水平下，在**有意义的时间**内将乘积分解是几乎不可能的。人们把「将特别大的乘积进行分解」这样一个问题，称为大数分解困难问题。

> 在密码学中，不存在「绝对不可破解」的密码——毕竟，只要时间和算力足够，总能使用暴力破解法一个个试出密码。但是，如果某个密码破解要 100 万年，那么这样的破解就没有实际意义。又如，某个信息的时效就只有 30 天，30 天后它就不再重要了，而对它的破解需要 40 天，这样的破解也没有意义。
>

1977 年，在麻省理工学院工作的罗纳德·李维斯特（Ron **R**ivest）、阿迪·萨莫尔（Adi **S**hamir）和伦纳德·阿德曼（Leonard **A**dleman）以大数分解困难问题为基础，设计了一款公钥加密算法，用三人的姓的首字母命名为 RSA，随后被大量广泛应用，直到今天。RSA 是第一个被广泛应用的非对称加密算法，在密码学的历史上有着非常重要的意义。

假设小明现在需要将一个机密信息 {{<katex>}}m=8{{</katex>}} 秘密地发送给小红。根据前文我们的介绍，小红需要准备自己的公钥和私钥，然后把公钥发送给小明。在 RSA 算法中，小红用这样的方法生成一对密钥：

- 小红首先随机地挑选两个超大质数 {{<katex>}}p{{</katex>}} 和 {{<katex>}}q{{</katex>}}。为了举例方便，我们就选择 {{<katex>}}p=2,q=11{{</katex>}}。实际上应用的 RSA 算法中这两个质数非常非常大。
- 计算 {{<katex>}}n=p\times q{{</katex>}} 和 {{<katex>}}\phi(n)=(p-1)(q-1){{</katex>}}。在例子中，{{<katex>}}n=22,\phi(n)=10{{</katex>}}。
- 小红随机挑选一个小于 {{<katex>}}\phi(n){{</katex>}} 且与它互质的数 {{<katex>}}e{{</katex>}}，比如说 3。
- 找到一个正整数 {{<katex>}}d{{</katex>}}，使得 {{<katex>}}(e\cdot d){{</katex>}} 除以 {{<katex>}}\phi(n){{</katex>}} 的余数为 1。此处我们选择 {{<katex>}}d=7{{</katex>}}

现在，小红将 {{<katex>}}(n, e){{</katex>}} 公开作为公钥，将 {{<katex>}}d{{</katex>}} 保留在自己手中作为私钥，并将 {{<katex>}}p, q, \phi(n){{</katex>}} 等销毁。至此，小红就完成了公钥和私钥的生成。

当小明需要向小红发送消息 {{<katex>}}m{{</katex>}}（满足 {{<katex>}}m<n{{</katex>}}）时，只需要计算
{{<katex display>}}
    C= m^e\,\mathrm{mod}\,n\text{，}
{{</katex>}}
其中 {{<katex>}}a\,\mathrm{mod}\,b{{</katex>}} 表示计算 {{<katex>}}a{{</katex>}} 除以 {{<katex>}}b{{</katex>}} 的余数。例如，对于上面的例子，消息 {{<katex>}}m=8{{</katex>}} 加密后的密文为
{{<katex display>}}
    C= m^e\,\mathrm{mod}\,n=8^3\,\mathrm{mod}\,22=6\text{。}
{{</katex>}}
小红收到 {{<katex>}}C{{</katex>}} 后，按式
{{<katex display>}}
    m= C^d\,\mathrm{mod}\,n
{{</katex>}}
就能解密出原始的明文 {{<katex>}}m{{</katex>}}，例如
{{<katex display>}}
    m= C^d\,\mathrm{mod}\,n=6^7\,\mathrm{mod}\,22=8\text{。}
{{</katex>}}

如果你看到这里并理解了上面的过程，你一定会有两个疑问：首先，为什么这样的计算能进行正确的加、解密；其次，为什么这样的密钥能保证安全。对于第一个问题，我们可以证明
{{<katex display>}}
    C^d\,\mathrm{mod}\,n=(m^e)^d\,\mathrm{mod}\,n=m\,\mathrm{mod}\,n=m\text{。}
{{</katex>}}
由于证明该式需要比较复杂的数学推导，限于我们的篇幅，这里略去不表。

> 上式证明的关键就是证明 {{<katex>}}(m^e)^d\,\mathrm{mod}\,n=m\,\mathrm{mod}\,n{{</katex>}}。证明它需要用到欧拉定理并分情况讨论，有兴趣的读者可以自行上网搜索。
>

对于第二个问题，即这样的密钥能否保障安全，我们需要证明「从公钥无法推导出私钥」。事实上，只要从 {{<katex>}}n=p\times q{{</katex>}} 难以反向推导出 {{<katex>}}p{{</katex>}} 和 {{<katex>}}q{{</katex>}}，就无法推出 {{<katex>}}\phi(n)=(p-1)(q-1){{</katex>}}，因而在拥有公钥 {{<katex>}}(n, e){{</katex>}} 时，无法计算出私钥 {{<katex>}}d{{</katex>}}。这就保证了拥有公钥的一方只能进行加密，而能进行解密的只有拥有私钥的人。

RSA 的安全性来自于大数分解问题的困难性。上面的例子中，我们为了举例方便，使用了很小的质数作为 {{<katex>}}p{{</katex>}} 和 {{<katex>}}q{{</katex>}}。实际上，目前广泛使用的 RSA 要求 {{<katex>}}n=p\times q{{</katex>}} 的长度为 2048 位——即数量级在 {{<katex>}}2^{2048}{{</katex>}} 左右。小于这一长度的密钥被认为是不安全的，而实践中 768 位的 RSA 已经被成功破解。可以想象，随着计算技术的不断发展，或许在未来，2048 位的密钥也不再安全，那时人们将只能选择更长的 3072 甚至是 4096 位密钥。

> 量子计算机的出现也正威胁着 RSA 的安全性——对于大数分解问题，传统计算机并没有高效的方法，但量子计算机不同，量子计算机可以高效地在合理的时间内解决这一问题，这让 RSA 的安全防线被直接攻破。
>

在这章的早些时候，我们提到了对称加密算法 AES，它常用的密钥长度是 128 位——这远远小于刚刚提到的 RSA 的密钥长度。这告诉我们，为了达到接近的安全性，非对称加密需要的密钥长度远远长于对称加密。同时，无论是 AES 还是 DES 算法，它们在内部的一切操作，都无非简单的位操作或是简单的查表替换，对于机器来说小菜一碟。而当我们再看 RSA 算法——先不论寻找两个 {{<katex>}}2^{1024}{{</katex>}} 数量级的质数的困难度，对于加密和解密过程，计算 {{<katex>}}m^e{{</katex>}} 和 {{<katex>}}C^d{{</katex>}} 这两个超级大的幂所需要的时间也不容小视。因此，在都能保障安全的情况下，非对称加密不仅密钥长度要长得多，加解密消耗的时间也要更大。

在 RSA 被提出以后，人们又基于一些其他的困难问题，设计了许多新的非对称加密算法，比如基于「离散对数困难问题」的 ElGammal 加密算法，以及基于「椭圆曲线离散对数困难问题」的一系列加密算法等。这些算法相比 RSA 各有优劣，在（相同安全性下的）密钥长度和运算速度上有一些提升。然而，与 AES 等对称加密算法相比，它们仍然要慢得多。这最终启发着人们将它们综合在一起，设计出兼二者之长处的混合加密系统，并最终让密码学在网络的世界中得到实际的应用。从此，在危机四伏的网络世界，密码学为人们铸造了一把利剑——安全、高效的保密通信从理论走向了现实。

> 一个朴素的混合加密思路是，将消息本身用对称加密算法加密后，把密钥用非对称加密算法交换。这样做是可行的，不过实际应用中并不是简单地这样将它们叠加，而需要严格的结构设计和验证。在密码学中，两个安全的密码算法嵌套，并不能得到一个一定安全的密码。

### 国产密码的意义

在前文介绍 DES 的过程中，我们提到 DES 的一大争议便是那不知从何处设计的 S 盒。一些学者担心这样的 S 盒存在漏洞，甚至是刻意留下的漏洞。尽管这样的论断是一种阴谋论，但不可否认的是，密码的设计者的确可以在密码中留下这样的「后门」，并将这样的后门出售给他人，从而使得保密通信能被他们更容易地破解。在商业行为中，这样的破解可能带来严重的经济、知识产权及至人才的损失，而当密码被大量运用于国家的运转中时，影响将变得不可估量。因此，将密码技术掌握在自己手中，是维护今天的国家安全的重要前提。

我国自进入 21 世纪以来，便开始着力推进国产密码的发展。除了对国家机密信息的加密研发专用的密码（称为「核心密码」和「普通密码」）外，还研发了许多用于非国家机密的民用密码产品（称为「商用密码」），供我国公民、企业和组织信息保护使用。其中的一个重要系列便是「商密」系列——它们使用「商密」两个字的拼音首字母 SM 命名。商密系列中的一些知名密码算法有：

- SM1：对称分组密码算法，算法细节不公开，需要在授权的硬件产品上使用。据报道，我国的居民身份证内的信息就是使用 SM1 加密的。
- SM2：椭圆曲线非对称密码算法，已公开为国家标准 GB/T 32918-2016。
- SM4：对称分组密码算法，采用类似 AES 的 S 盒设计，已公开为国家标准 GB/T 32907-2016。得益于计算上的性能优势，SM4 主要在一些无线网络产品中应用。

除了商密系列之外，还有一些知名的国产密码在今天已被广泛应用，如应用于 4G 移动网络中的「祖冲之密码」（ZUC 密码）等。

密码是重要的国家战略资源，今天的密码算法比历史上任何时候都更加重要。2020 年 1 月 1 日，《中华人民共和国密码法》正式实施，我国的密码科学发展有了法律的支撑，我国公民、组织和政府对网络空间合法权益的维护也有了更加强大的法律武器。下一节，让我们从密码学的基础出发，看一看今天的网络世界，是如何在密码的保护下从危机四伏中绽放的。

## 执密码之剑保驾护航

现代密码学是当下网络安全的核心基础。当你使用浏览器在手机或电脑上访问《你缺计课》网页版时，正是一系列密码技术保障着网页内容完整、无误地从我们的服务器传输到你手上，同时不被恶意的攻击者所干扰。现在，把目光放到你使用的浏览器的地址栏，看看能不能在网址前方找到一个挂锁的图标：

![浏览器地址栏的挂锁](introduction-to-cryptology/Lock_signs_in_browsers.png#center)

上图中，上方为火狐浏览器，下方为 Chrome 浏览器。这个挂锁图标表示你打开的网页采用「HTTPS」传输——这是一种融合多种密码学技术来加密网页和数据的技术。在今天，我们日常生活中访问的大多数网站都正在使用 HTTPS。HTTPS 仿佛一把密码之「剑」，为我们的网页数据保驾护航。下面，就让我们深入其中一探究竟。

{{<hint warning>}}

**如果可能，不要在任何没有启用 HTTPS 的网站上输入任何敏感信息**，包括身份信息、登录密码等。我们已经提到多次，在互联网上传输的数据，如果不进行加密保护，就可以轻易地被截获和修改。因此，当一个网站没有启用 HTTPS 但是你又在上面输入了这些信息，就可能存在危险。

目前，大多数浏览器会使用醒目的提示标记未启用 HTTPS 的网页，例如被红色斜杠划掉的挂锁、三角警告图标以及【不安全】字样。除此之外，我们还可以通过查看完整网址的开头来判断网页是否启用 HTTPS——启用了 HTTPS 的网页，网址以 `https://` 开头，而未启用的则为 `http://` 开头，少了一个 `s`。

目前，我国仍然有一些政务、银行网站等由于历史原因未启用 HTTPS。在它们诞生的年代，比较流行的一种做法是在网页内部用自己的方式实现敏感信息的加密，而不是使用通用的 HTTPS。作为一些特例，在这些网站上输入信息理论上是安全的，不过在使用它们前，请仔细检查确认你所使用的网站是否为官方网站。

{{</hint>}}

### 危机与挑战

在本章的开头我们就说到，网络世界「危机四伏」。就以你正在阅读的《你缺计课》为例，这些文字从我们的服务器被传达到你的眼前，面临的危机与挑战大体可以分成三个方面：

1. 我们需要实现数据的**保密性**。前文提到，互联网的「分组交换」组织模式，让其上的数据传输形同「裸奔」。在互联网上，无数的攻击者各自心怀鬼胎，无不盯着我们传输数据的具体内容虎视眈眈。实现对恶意攻击者保密的双向通信，已然成为利用互联网上的必选项。
2. 我们需要保护数据的**完整性**。否则，攻击者可以通过拦截的方式，让信息中的部分内容消失，或更换为其他的内容，这样的后果是极为严重的——在后文，我们将举一个例子来说明。
3. 即使已经实现了完整与保密的通信，我们还需要时刻关心一件事：与你通信的对方，真的是你希望通信的对象吗？试想，如果有攻击者截获你访问《你缺计课》服务器的请求，并伪造出一个假的《你缺计课》网页发回给你，内容全部充满错漏和误导，事情就会变得一团糟。实现一种**可认证性**，


### 字字皆「机密」——加密与解密

### 完整才是硬道理——校验和与哈希

在《你缺计课》的 [软件的寻找与安装]({{<ref "software-installation.md">}}) 一章中，我们提到过这样一句话：

{{<hint quoting>}}

不要把大量的软件安装在 C 盘……

{{</hint>}}

如果某个攻击者在文章从服务器向我们传输的过程中，将「不」字对应的数据替换成「需」字，或者干脆直接拦截这个「不」字，但让其他数据正常发送，整个句子的含义就会整整转变 180 度；这种「偷梁换柱」「断章取义」的风险让我们意识到保护数据的完整性极为重要：**有些时候，错误的、误导性的信息，会比错过信息更加危险。**

那么，如何保障数据传输的完整性呢？对数据进行加密就是一种重要的方法。诶——可是数据加密主要是保证「别人看不懂数据」，怎么防止攻击者修改、破坏部分数据呢？如果你仔细地阅读了「蓬勃发展的密码学」一节，在前文我们提到过，今天多数加密算法都可以实现「改变明文中的一小处，整个密文都会变化」——这意味着明文的影响被扩散到了整个密文当中。这样，当数据被加密传输时，攻击者就很难精确地修改和破坏特定部分的数据了。明文的每一个字都会影响整个密文，反过来更改密文中的每一部分都会影响整体的解密。

不过，仅仅借助加密来实现数据完整性的保护是远远不够的。像 DES、AES 这样的分组加密算法，是将完整的数据「切」成一个个固定长度的小块进行加密的，这使得我们刚刚提到的这种扩散影响将只局限于每一块内部。尽管人们提出了许多解决这一问题的方案，但是「道高一尺，魔高一丈」，精明的攻击者也在不断地寻找这些方案的漏洞。为了保护数据的完整性，我们需要转换思路：在想办法防止一部分数据被破坏之外，我们还应该设计一种能够判断数据是否完好的方式：这样，在收到数据之后，我们只用通过一次检测，就能知道数据完好与否了。

现在，让我们先把目光看向我们手中的身份证。在我国，每个人的居民身份证上都印有由 18 个数字（和字母）组成的公民身份号码，但事实上，这 18 个数码的最后一位是由前 17 个数按照下面的算法计算出来的：

- 先将第 1 至 17 个数分别乘以下表提供的系数；

  | 第几个 | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  |
  | ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
  | 系数   | 7   | 9   | 10  | 5   | 8   | 4   | 2   | 1   | 6   | 3   | 7   | 9   | 10  | 5   | 8   | 4   | 2   |

- 然后，将这 17 个乘积相加，再除以 11 求余数；
- 查找下表，确定最后一位的值。

  | 余数     | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
  | -------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
  | 最后一位 | 1   | 0   | X   | 9   | 8   | 7   | 6   | 5   | 4   | 3   | 2   |

这套算法被称为 MOD 11-2，定义在国际标准 ISO 7064 中。最终计算出来的值被称为「校验码」，它能够用来帮助判别整个号码是否存在错误——假如某人在输入自己身份号码时，不小心写错了其中的几个数，那么最终计算出来的校验码，就很可能与号码最后一位不一致了——当检测到这种不一致时，或发现输入的号码位数不正确时，就可以让系统给出「号码有误」的提示，从而避免后续的麻烦。

> 不妨用自己的身份号码代入上面的算法，计算出来的校验位是否匹配？随机地修改其中的几位再计算呢？
>

如果我们设计一种类似的算法，给要传输的数据也计算一个「校验码」，并将这个「校验码」与数据本身一同发送——当接收方收到信息后，重新计算一次「校验码」并与之进行比对，不就能保障数据的完整性了吗？当然是完全可行的！不过，由于通信传输的数据通常不只有几个数字那么简短，计算得到的「校验码」自然不像身份号码那样只需要一位数码就能写下，我们将这样的「校验码」称为「校验和」（checksum）。CRC32 是常用的一种校验和，它的输出长度为 32 位，即是位于 {{<katex>}}0{{</katex>}} 和 {{<katex>}}2^{32}-1{{</katex>}} 之间的数字。我们选取了一些字符串作为输入数据，计算了它们的 CRC32 校验和如下：

| 字符串    | CRC32 校验和 | 字符串    | CRC32 校验和 |
| --------- | ------------ | --------- | ------------ |
| `Missing` | 1254083771   | `Mis5ing` | 3234525209   |
| `Missinh` | 1097985814   | `missing` | 2050358017   |
| `Missin`  | 3616188434   | `Mising`  | 2486458582   |

我们不难发现，只要输入字符串中有任意一个字符发生改变（变化或缺失），计算得到的校验和就会有非常明显的改变。这说明校验和具有**敏感性**，能够对极小的变化作出巨大的反应，这让它能有效地检测出数据是否完整——只要实际校验和与传输的值不一致，就说明数据被破坏。

要使用校验和来保证数据的完整性，为了防止攻击者将消息本身和校验和一同篡改，我们仍然需要借助加密的力量。对于要发送的数据，我们先计算它的校验和，将数据与校验和拼接在一起一同加密并传输。接收方收到密文后，先将消息解密，再重新计算校验和检验完整性。由于攻击者很难在破坏消息的同时伪造出新的校验和，更难以将伪造的校验和重新进行加密，数据的完整性在这其中便得到了保护。下图是展示了这一过程。

![使用校验和与加密算法保障完整性](introduction-to-cryptology/Use_checksum_with_encryption.png#center)

看起来，使用校验和就可以完美地解决「判断数据完好」这一任务了。不过我们还剩下一个小问题：会不会存在两个数据具有相同的校验和呢？答案是肯定的——还是以身份号码为例，由于校验码一共就 0—9 再加上 X 十种情况，人群中很容易就找到两个人的身份号码具有相同的校验码。而在我们刚刚提到的 CRC32 中，校验和亦只有 32 位，一共也只有 {{<katex>}}2^{32}=4\,294\,967\,296{{</katex>}} 种情况，攻击者是有可能构造出具有特定校验和的数据的。在一些极限情况下，攻击者能够在伪造消息的同时保持校验和不变——如同从 DES 走向 AES 的过程一样，人们需要一种更长、更安全的「校验和」，哈希函数自此登上了历史的舞台。

哈希是 hash 的音译，它的本意是「一团糟」。在密码学中，哈希函数和校验和看起来很像，都能针对任意长度的输入数据计算出一个固定长度的值（称为哈希值），并且极具敏感性。不过，校验和的内部是基于比较简单的数学运算而设计（例如前文提到的 CRC32 就基于二进制除法），输出长度比较短，而哈希函数内部由多次重复而复杂的操作组合而成。打个比方：如果说原始数据是一张 A4 纸，校验和就好比将纸来回折两下，然后剪下一个角作为结果；而哈希函数则是先将纸按某种方式折叠多次，切成片后再按某种顺序重新压平，换个方向叠放，再来回这样处理十几次，最后撕碎再取若干碎片作为结果。这也许就是 hash 一词的来源，也是其常用意译「散列」「杂凑」的来源。

与校验和相比，哈希函数除了具有更强的敏感性之外，还具有很强的**单向性**和**抗碰撞性**——首先，我们几乎不可能从哈希函数的输出反推输入，即使输入的一部分已经给出，反推完整输入依然十分困难。同时，对于同一个哈希值，几乎不可能找到两个不同的输入与之对应；而给定一个输入，亦几乎不可能找到另一个输入与它有相同的哈希值。此外，哈希函数的输出通常较长。目前常用的哈希函数 SHA-256 能产生 256 位的输出，远远安全于 CRC32 的 32 位。自然而然地，哈希函数取代了校验和，成为了事实上的维护数据完整性的守护神。

在许多软件的下载界面，开发者会在网页上提供一个哈希值（通常使用 MD5 或 SHA-256），这样我们下载软件之后，可以在安装之前自行计算一遍哈希值并与开发者提供的相比对，从而确保我们下载的文件完好无损。下图中，上方为开源音频编辑软件 Audacity 下载页面提供的哈希值，下方则是下载 Go 编程语言的编译器时提供的 SHA-256 值。

![下载界面提供的哈希值](introduction-to-cryptology/Hashes_at_download_page.png#center)

而回到你正在阅读的《你缺计课》，我们使用的 HTTPS 技术亦在使用 SHA-256 对数据进行校验，来确保你看到的文字没有在传输过程中遭到修改。如果你正在使用火狐浏览器阅读本网站，不妨点击地址栏前方的挂锁图标，选择【连接安全】→【更多信息】，就能在【技术细节】下方看见：

{{<hint quote>}}
连接已加密（`TLS_AES_128_GCM_SHA256`，128 位密钥，TLS 1.3）
{{</hint>}}

这其中的 `SHA256` 就是指 SHA-256。

### 铸就「信任」的链条——签名与证书