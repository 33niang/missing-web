---
title: 万言皆数——字符与编码规则
type: docs
# draft: true
---

# 万言皆数——字符与编码规则

{{< hint info >}}
这一章让我们来一探「字符」在电脑世界中的奥秘。或许曾经有人告诉你，在数字世界中，一切不过是由 `0` 和 `1` 交替组合而成的数据罢了。那么，这些看似毫无规律的「数」，是如何和人类的万千语言对应上的呢？「编码」就是解决这一切问题的答案。看完这一章，也许你就能找到这些问题的答案：

- 二进制、十进制都是什么？「字节」又是什么？
- 世界上那么多种文字，为什么计算机能完整地表示它们？
- 为什么我在网上或一些 app 中，有时会看见各种各样的乱码？例如：
  - 浣犵己澶辩殑閭ｉ棬璁＄畻鏈鸿
  - ä½ ç¼ºå¤±çš„é‚£é—¨è®¡ç®—æœºè¯¾
- 在使用电脑的过程中，我们如何避免这样的乱码的产生呢？
{{< /hint >}}

语言文字是文化的基础要素和鲜明标志，是推动人类进步的重要力量。文字作为语言的载体，在进入信息时代后，「如何把文字在计算机系统中表示」就成为了至关重要的问题。将目光投向电脑的屏幕，这一章，我们会来看看我们使用电脑时必然会见到，却又不太明白个中奥秘的内容——屏幕上显示的文字与它背后的「数字」。

## 机器中数的表示

在了解文字与数之间的关系之前，我们有必要先简单学习一下，计算机中的「数」如何进行表示。

### 进制

所谓「进制」，本质上说的是<ruby>数<rp>（</rp><rt>shǔ<rp>）</rp></ruby><ruby>数<rp>（</rp><rt>shù<rp>）</rp></ruby>的方式。小时候的数学第一课就是教导我们怎么数数，掰着手指，借助 0 到 9 这 10 个阿拉伯数字，我们学到了一种「逢十进一」的数数方式：
{{<katex display>}}
0\rightarrow 1\rightarrow\cdots\rightarrow 9\xrightarrow{\text{进位}}10\rightarrow 11\rightarrow\cdots
{{</katex>}}
逢十进一就是说，我们每数十个数，就要进一位，然后重新开始数十个数。如此一来，借助十个数字，我们就能将所有自然数都表示出来，这种数数方式就是人尽皆知的「十进制」。

但如果允许使用更多数字会怎么样？例如，假定使用 0 到 9 以及 A 到 F 一共 16 个符号作为「数字」，我们就可以设计这样一种数数方式，逢十六进一：
{{<katex display>}}
\begin{aligned}
0\rightarrow &1\rightarrow\cdots\rightarrow 9\rightarrow \mathrm{A}\rightarrow \mathrm{B}\rightarrow\cdots\rightarrow \mathrm{F}\xrightarrow{\text{进位}}10\rightarrow \\
&11\rightarrow\cdots\rightarrow19\rightarrow1\mathrm{A}\rightarrow\cdots\rightarrow 1\mathrm{F}\xrightarrow{\text{进位}}20\rightarrow 21\rightarrow\cdots
\end{aligned}
{{</katex>}}
这就产生了一种更高的进制——「十六进制」。

另一方面，限制我们能使用的数字个数，也可以设计出更低的进制——极限情况下，让可用的数字只留下 0 和 1，自然而然就产生了这样「逢二进一」的数数方式：
{{<katex display>}}
0\rightarrow 1\xrightarrow{\text{进位}}10\rightarrow11\xrightarrow{\text{进位}}100\rightarrow 101\rightarrow\cdots
{{</katex>}}
这就是「二进制」。

> 那有没有「一进制」呢？（笑）

把数字按上面不同的数数方式并排列出，一一对应，我们就能得到进制之间的转换关系，这就是同一个自然数在不同进制下的表示方式。

| 十进制 | 十六进制 |   二进制 |
| -----: | -------: | -------: |
|      0 |        0 |        0 |
|      1 |        1 |        1 |
|      2 |        2 |       10 |
|    ... |      ... |      ... |
|      9 |        9 |     1001 |
|     10 |        A |     1010 |
|     11 |        B |     1011 |
|    ... |      ... |      ... |
|     15 |        F |     1111 |
|     16 |       10 |    10000 |
|     17 |       11 |    10001 |
|    ... |      ... |      ... |
|     43 |       2B |   101011 |
|    ... |      ... |      ... |
|    255 |       FF | 11111111 |
|    ... |      ... |      ... |

当然，为了计算一个数在某种进制中的表现，我们没必要像这个表一样总是从零开始数，而可以直接计算——例如，将十进制数转换为对应的{{<katex>}}k{{</katex>}}进制数，可以采用「除{{<katex>}}k{{</katex>}}取余法」。你可以自行在网上搜索这个方法的细节。

值得一提的是，高进制下（例如十六进制），依然有些数是不包含字母的，此时如果不加额外说明，没人看得出它到底该是几进制。为了避免混淆，除了在上下文中特别说明（例如，「十六进制数 43」）之外，人们还习惯在不是十进制的数字表示中加上一些特殊标记：十六进制数可以在前面加上一个 `0x`（一个数字零和一个字母 x）或在尾部加上「ʜ」的后缀（hexadecimal 的首字母）；二进制数在前面加 `0b`（数字零和字母 b）或在尾部加上「ʙ」的后缀（binary 的首字母）。在后文中，我们将沿用这种标记。另外，除非特别说明，像 `114514` 这种框起来样式的数字，默认是十六进制。

### 计算机与二进制

在计算机内部，信息由电路承载，而电路总是只能处在「<span style="color: #11CD08;">有电</span>」「<span style="color: #114514;">无电</span>」[^pinstate]两种状态中的一种。如果我们把「<span style="color: #11CD08;">有电</span>」记成 1，「<span style="color: #114514;">无电</span>」记成 0，那么计算机内的一条电路就自然而然地对应到一个二进制数上了，这样传输的一个数字称为一「比特」或一「位」（bit）。假设机器内部，有一处使用 8 根并排的电路用来传递数据，我们就称这样的数据「宽度」为 8 位或 8 比特。如果这 8 根电路在某一时刻的状态是：

[^pinstate]: 严格来说是「<span style="color: #11CD08;">高电平</span>」与「<span style="color: #114514;">低电平</span>」。除此之外，电路可能处在类似悬空的「高阻态」。

| 电路 | 最高位 |      |      |      |      |      |      | 最低位 |
| ---- | :----: | ---- | ---- | ---- | ---- | ---- | ---- | :----: |
| 状态 |  <span style="color: #114514;">无电</span>  | <span style="color: #11CD08;">有电</span> | <span style="color: #11CD08;">有电</span> | <span style="color: #114514;">无电</span> | <span style="color: #114514;">无电</span> | <span style="color: #114514;">无电</span> | <span style="color: #11CD08;">有电</span> |  <span style="color: #114514;">无电</span>  |

它传递的数据就是二进制数 `01100010`，转换成十进制就是 98。人们把这样的一个 8 位数据称为一个「字节」（byte）。如果稍微做一点数学运算，你会发现{{<katex>}}2^8 = 256 = 16^2{{</katex>}}，这也就意味着一个字节也可以用 2 位十六进制数来表示。

> 一个字节能存储的最小数是二进制的 `00000000`，最大数是 `11111111`，请自行计算或利用工具计算它们对应的十进制数。

## 万言皆数

「万物皆数。」这是古希腊数学家毕达哥拉斯的信条，也是他创建的学派的信条，他们为万事万物赋予数字，而为数字赋予意义。如此想法在今天看来显然如同宗教一般神秘而虚无缥缈。但在电脑的世界中，所有的事物的的确确是内存、硬盘等等硬件中的一个个 0 与 1，「万物皆数」的观点在这里得到了淋漓尽致的展现。然而文字——人类为记录语言而创造的工具，在这「数」的世界中亦不可避免成为庞大数据的一部分，那么，电脑是如何令文字化为数字存储在其中，又如何令数字化为文字得以展现在我们眼前的呢？

### 编码——让字符有代号

古时人们传递信息，大多用文字写下，使用信件传递。但在一些特殊场合，例如需要飞速传递信息，或者在海上航行之类的的情形下，承载信息的文字就必须另辟蹊径才能传达到对方手中，这让人们开始思考如何为文字设计一种代号，来适应这些极端的情况。于是，「编码」的概念就此诞生。

彼时的编码，可以多种多样，例如旗语——使用特定的旗帜朝向组合来代表一个个字母；或者著名的摩尔斯电码——利用线与点的组合代表长短信号的序列，进而表示字母；又或者直到 20 世纪 80 年代还在广泛使用的中文电码——将汉字用四个数字或三个字母表示，再利用摩尔斯电码化为长短不一的信号……下图分别展示了国际摩尔斯电码与你可以在 1986 年用六毛钱买到的《标准电码本》中的某一页。

![电码](characters-and-encodings/TelegraphCode.jpg)

而接受编码的对象，可以是一个汉字、一个字母、一个标点，甚至一个「接到这个信号就表示信息发完了」的「虚拟字」。所有这些，我们给它们起了一个名字——「字符」（character）。

随着电子时代到来，0 与 1 的波浪占据了信息传递的方方面面，「编码」的含义也随之变成了「为每一个字符分配一个特定的数字以代表它」。

### ASCII——故事真正的开始

ASCII，全名「美国信息交换标准代码」（American Standard Code for Information Interchange），是美国国家标准协会（ANSI）——的前身美国标准组织（ASA）在 1963 年为改进电报编码而制定的编码规则。

> 所以 ASCII 的「II」不是罗马数字 2，也不能读成 ASK-二，而应该是 ASS-key。

20 世纪 60 年代初的美国，电报通信还是电传打字机的天下，它们遵循叫做「国际电报字母第 2 号」（ITA-2）的编码规则。但这 ITA-2 编码非常抽象，它不仅没有规律，还只有大写，要想输入数字和标点还需要特定的「虚拟字」来转换码表。后来的 TSS 编码虽然加入了小写，可其他问题一个没改。天下苦乱糟糟编码久矣，于是 ASCII 横空出世，带来了非常漂亮的编码规则。

![ITA-2](characters-and-encodings/ITA2.png)

ASCII 使用 7 位二进制数来编码字符，可以表示的数据范围是 0—127，也就意味着它能包揽英文字母（{{<katex>}}2\times26=52{{</katex>}} 个）、阿拉伯数字（10 个）、常用标点符号（二三十个），甚至还有空余。ASA 也没闲着，确实往这些剩下的空位里面塞进了许多「控制字符」，也就是上文所述的「虚拟字」。下图是 1967 年版的 ASCII 编码标准，共 7 列 16 行，「0」列与「1」列都是控制字符，用来控制通信设备；数字在「3」列，可见 `30` 就是 0，`31` 就是 1……挺方便；「4」列、「5」列有按字母表排列的大写字母，隔壁的「6」列、「7」列中相同的位置有小写字母；剩下的地方全是标点符号了。

![ASCII](characters-and-encodings/USASCII_code_chart.png)

按照这这张表，一个字符可以用两个十六进制数字表示，第一个是列数，第二个是行数。例如「Missing!」编码出来，用十六进制数表示就是 `4D697373696E6721`，看不懂没关系，机器能明白。值得一提的是，1963 年的初版 ASCII 并没有加入小写字母，而是把那一块空出来了，后来人们发现不妥，于是在初版发布的几个月后就立马加上了小写字母。如此一来，英文的文字通信需求就被这一张表完美涵盖了。

1968 年 3 月 11 日，当时的美国总统林登·约翰逊要求美国政府购买的所有电脑都必须支持 ASCII 编码，自此，ASCII 成为了事实上的编码标准，也成为了众多其他编码规则的祖先。

### 百花齐放的代码页

相信大家都知道，1 个字节由 8 个二进制数组成 ~~（认真读完本章第一节的应该都知道）~~，但 ASCII 诞生的那个年代人们还没有这个意识，这也就是为什么 ASCII 是 7 位二进制数码。1968 年，高德纳在他的《计算机程序设计艺术》第一卷中假想了叫做「MIX」的电脑，在它之中，一个「字节」应当「包含不定量的信息……能够容纳至少 64……至多 100 个不同的值……应有 6 个二进制位」。但到了 1970 年，Intel 推出了划时代的 8080 处理器，风靡全球，而它是 8 位的，于是乎「字节」一词顺理成章地逐渐变成了「8 位二进制数单元」的代名词。在此之后研发的处理器，例如 8080 的后继者——80x86 系列，它们的位数都是 8 的倍数，「字节 = 8 位二进制数单元」也变成了人们不可撼动的共识。

7 位的 ASCII 移植到 8 位实在不费吹灰之力，前面加个 `0` 就行。但是 80 年代以来，电脑随着科技革命的浪潮，散布到了世界的各个角落。与此同时，两大难题也随之而来：
- 法国有「é」，德国有「üß」，俄罗斯有「иящ」，日本有「あいう」，中国有「天地人」……大家都需要在电脑上显示自己的文字，那怎么办呢？
- 像法国、德国等西欧国家，使用的字母相比英语而言只多那么有限的几个，ASCII 只占了 128 个位置，8 位的字节可支持 256 个位置，只要在剩下的空格里加上所需的就可以了。然而世界其他地方的国家就没这么好说了，中文甚至有成千上万的汉字，显然不是简简单单就能塞得下的。对于这些有大量额外内容的文字，又该如何制定合适的编码规则以容纳它们呢？

一个简单的想法是，把大伙用到的字符全收集起来，然后统一编码即可。可惜想法很美好，技术与钱包不同意。1985 年，普通个人电脑的硬盘大约只有 10 MB 的容量，却要花高达 250 美元才能买到，寸土寸金的硬盘空间让人们只能寻求替代方案。于是，为了解决这些问题，IBM 与微软一起，在 DOS 3.3 版本时推出了全新的全球化功能——代码页（code page）。

代码页的思想是，将各种不同的文字系统赋予一个数字代号，操作系统识别这个数字代号，就知道当前应当是哪种语言、使用什么文字编码。IBM 与微软主要负责为各种文字系统指定代号，而为文字编码，则交给各个国家与地区的机构完成。不过，一种语言可能有很多编码，一种编码也可以由多种语言使用，所以事实上，代码页和编码规则是一一对应的。下表是最初的部分代码页/语言/编码规范对应表。[^codepage]

[^codepage]: 虽然 819 和 1252 是不一样的代码页，但网页显示会把 819 视作 1252 来解析。

| 代码页 |     语言     |                             编码规范                             |
| :----: | :----------: | :--------------------------------------------------------------: |
|   38   |   美国英语   |                             US-ASCII                             |
|  819   | 英语、法语等 |     ISO 8859-1:1998 8 位单字节编码字符集——拉丁字母：第 1 号      |
|  932   |     日语     | JIS X 0208 7 位及 8 位双字节信息交换用符号化汉字集合[^shift-jis] |
|  936   |   简体中文   |          GB/T 2312-1980 信息交换用汉字编码字符集 基本集          |
|  950   |   繁体中文   |                              大五码                              |
|  1252  | 英语、法语等 |                         WHATWG 编码规范                          |

[^shift-jis]: 又称 Shift-JIS。

如此一来，第一个问题解决了，世界各地的电脑可以通过代码页来决定使用什么编码规范了。但第二个问题呢？让我们翻开手边的《GB/T 2312-1980 信息交换用汉字编码字符集 基本集》（以后简称「GB2312」）来看一看。这是我国的国家标准之一，其中收录了 6763 个最常用的汉字，能够满足绝大多数情况下的日常使用。为了排布那 6763 个汉字，以及额外收录的希腊字母、西里尔字母、注音符号、日文假名等内容，GB2312 不再局限于单个字节，而使用了「区位码」的方法——先将码表分为 94 个「区」，每个区中又有 94「位」，这样总共{{<katex>}}94 \times 94 = 8836{{</katex>}}个位置——或者说「码位」，足够容纳下这么多字符了。整个标准中，1~9 区放字母与符号，16~87 区放汉字，剩下的没用到。下图展示了第 16 区容纳的内容。

![GB2312](characters-and-encodings/GB2312.png)

占了 87 个区的这些内容，可以用两个字节来分别表示，一个标识区、一个标识位。但是 GB2312 并没有规定区位码和编码字节值一定要一样，于是在实际实现中，为了不和 ASCII 打架，区码就使用了 `A1`~`F7` 的 87 个十六进制数，位码使用了 `A1`~`FE` 的 94 个十六进制数。例如上图中的「凹」字，位于 16 区 28 位，那么它的编码就是 `B0BC`。这样，整个编码体系就建立完成了。

目前看来一切都还不错，直到人们发现 GB2312 漏掉了一些经常使用的字，例如在「啰嗦」这个常用词中的「啰」，以及许多人名字中的生僻字，例如「镕」。一方面，人们为了能够显示出这些字，使用了一系列替代方案，比如拼字或者换专用字体：

{{< hint quoting >}}
「少<span style="display: inline-block; transform: scaleX(.5) translateX(-.51em); width: 1em; white-space: nowrap;">口罗</span>嗦！」方<span style="font-family: simsun, serif;">镕</span>打断道。
{{< /hint >}}

另一方面，人们也在推动更多字符被收进编码体系中。经历了十几年的努力，1995 年，《汉字内码扩展规范》发布，通称「GBK」，意为「国标扩」，收录汉字的总量达到了 21003，代替了 GB2312 在代码页 936 中的位置。它在双字节中没有用上的很大一部分都塞上了汉字，如下图「GBK」部分所示，其中「GBK/1」「GBK/2」部分就是 GB2312。而为了避免与 ASCII 相冲突，GBK 仅使用 `80` 及以上的值作为双字节编码开头。

![GBK](characters-and-encodings/GBK.png)

然而 GBK 并不是一个纸面上的国家标准，而只是一个被人们广泛采用而造就的「事实标准」。于是又过了几年，在 GBK 的基础上，国家标准委员会推出了《GB 18030-2000 信息技术 信息交换用汉字编码字符集 基本集的扩充》，收录了 27533 个汉字，其中包括许多繁体字与生僻字。为了收录这么多汉字，标准增加了四字节编码的部分：四字节由两个特定的双字节构成，如上图绿色部分所示，那一块一共 1260 个码位，可以表示{{<katex>}}1260^2 = 1\,587\,600{{</katex>}}个字符。~~（根本用不完，哈！）~~ 自此，更多的中文字符被官方标准的编码体系所囊括，除了极为生僻的古文用字，几乎不会有「缺字」的情况出现了。

之后二十来年，国家不断修订这个标准，目前最新的修订版是《GB 18030-2022 信息技术 中文编码字符集》，不仅收录了 87887 个汉字，更收录了朝鲜文、蒙古文、藏文等我国许多少数民族使用的文字，成为了我国各民族都可使用的通用标准。以下是一些文字在 GB18030 最新版中的编码对应关系。

| 文字  | 编码       |
| :---: | :--------- |
|  绝   | `BEF8`     |
|  𪩘   | `9836CF34` |
|  랓   | `8239FB38` |
|   དྷ   | `8132F036` |

通过对中文编码的一瞥，我们已经领会了如何给拥有巨大文字量的文字系统编码，其他文字系统的代码页也是相似的思想。而且几乎所有的代码页都不约而同地将 ASCII 的部分留了下来，令 ASCII 编码的内容无论以何种代码页解析都能得到正确的结果，这也就是为什么我们说「ASCII 是众多其他编码规则的祖先」。不同的代码页服务着世界各地讲不同语言、使用不同文字的电脑用户，让所有人都能享受到信息时代带来的便利与乐趣。

但转念一想，「代码页」的工作方式，似乎将重点放在了「决定这个代码页中含有哪些文字」，在确定了这些事之后，才去思考、制定对应的编码规则。所以，「代码页」的本质应当先是一种「字符集」（character set）——首先是一系列特定字符的集合，然后才是与之对应的编码方式。

### Unicode 与 UTF 的大一统时代

虽然上文说过「把大伙用到的字符全收集起来，然后统一编码……技术与钱包不同意」，但早在 1987 年，仍然有人开始尝试这项工作。那一年，造打印机的施乐（Xerox）的员工乔·贝克尔（Joe Becker）开始尝试创建一种「通用字符集」，并在许多人的帮助下，于次年发布了一份「国际化/多语言的字符编码系统」草案，名为 *Unicode 88*。这就是「Unicode」（统一码）这个名字的起源，它代表了一种为全球每一种语言所用文字制作统一而通用的编码方案的美好愿景。

![Unicode](characters-and-encodings/UnicodeLogo.png#floatright)

显然，若想为全球每一种语言的文字编码，必定需要大于 1 字节的方案。在 *Unicode 88* 中，贝克尔设想了一种「宽体 ASCII」——使用两字节来编码字符的方案。贝克尔认为「在合理的设计下，每个字符 16 位（二进制）编码已经绰绰有余」，然而上文我们已经看到，在三十多年后，仅仅汉字一项，就已经达到了八万多字符之巨，这样的编码方案显然是不能满足长期使用的。

*Unicode 88* 发布后的几年，Unicode 工作小组仍在不断改进这个草案，对编码的字符各种重排，以求更好的效果。1991 年 1 月 3 日，Unicode 联盟成立，右图是它现在的徽标（之前的徽标是暗红色的）。同年十月，《Unicode 规范》第一版发布，这标志着字符集的制定进入了新时代——全球化的大一统时代。

与此同时，国际标准化组织（ISO）也在干差不多的活，但是两拨人互相不知道。~~（这就是缺乏调研与沟通的后果。）~~ 1990 年，《ISO 10646 通用多八位编码字符集（草案）》发布，规定了一种有「128 组，每组 256 面，每面 256 行，每行 128 单元」的字符集。虽然算下来它能包含{{<katex>}}2^{32}{{</katex>}}个字符，但说实话……这有点复杂了。大伙都不看好这种编码方案，于是 ISO 终于找到了 Unicode 工作组，并协商让两个标准统一，Unicode 有了 ISO 的支持，成为了国际标准的一份子。

前面我们讲过，代码页是字符集和与之对应的编码方式之和，但 Unicode 联盟并没有打算先制作字符集，然后再去指定每个字符应该有什么编码，甚至确定它长什么样子。与此相反，Unicode 联盟把这件事拆成了三部分：
- Unicode 负责字符集部分——指定一个字符使用哪个码位；
- Unicode 转换格式（Unicode Transformation Format，简称 UTF）负责编码部分——确定某个字符码位如何在计算机中存储；
- 字体负责显示部分——字符最终呈现在我们屏幕上的样子。

接下来我们依次来看看这三部分是怎么工作的。

#### Unicode 与文字码位

Unicode 收录一种文字的基本流程大概是：
1. 当地机构先收集这种文字可能用到的所有字符，将它们提交给 Unicode 联盟；
2. Unicode 联盟开会，各成员投票决定收录不收这些文字，过半数则同意；
3. 若同意收录，则按字符数量在 Unicode 码表中划一块区域放进去，等到下一版正式发布时就会成为不变的标准。

当今的 Unicode 收录了各式各样很多字符，除今天世界各地的人们都在使用的文字以外，还包括各种表情符号、音乐符号、棋牌符号，甚至埃及圣书体、楔形文字等等古代文字。

但是原本 Unicode 设计的是「每个字符 16 位二进制码」，也就是 65536 个字符，我们早已知道这不够用。Unicode 联盟意识到这个问题之后，引入了类似 ISO 当初设想的「平面」（plane）概念，但远没有 ISO 方案那么复杂。他们将 Unicode 的字符范围分为 0~16 号总共 17 个平面，每个平面正好 16 位二进制码，65536 个字符，这样算下来就有{{<katex>}}17 \times 65536 = 1\,114\,112 = \mathrm{110000}_\mathrm{H}{{</katex>}}个码位，于是，Unicode 的字符码范围就是 0ʜ~10FFFFʜ，这下够用了。

16 位二进制码，用十六进制数字表示就正好是 4 位，再加上所属平面的号码，就构成了 Unicode 码位的十六进制表示。为了特意说明这是 Unicode 码位，人们通常令码位至少有四个数字（即前面补 0），并在码位前面加上 `U+` 的前缀，以下是一些字符和与之对应的平面号码和 Unicode 码位：

|   字符    | 平面  | 码位      |
| :-------: | :---: | --------- |
|     0     |   0   | `U+0030`  |
|     √     |   0   | `U+221A`  |
|    🤣     |   1   | `U+1F923` |
| 𰻝[^biang] |   3   | `U+30EDD` |

[^biang]: 这个是陕西名吃「biǎngbiǎng 面」的 biǎng 字。

截至 2024 年 10 月，最新的 Unicode 标准版本是 16.0，共收录约 15.5 万个字符，但是这些字符仅仅占了寥寥部分平面而已，我们来看看它们的分布。

Unicode 的第 0 平面叫「基本多文种平面」，又称「基本区」，下图是该平面内的大致字符分布，每个框框有 256 个码位。顾名思义，这个平面是最基本，也是最重要的平面，它包含了世界上大多数主要语言的文字。一眼望去，占大头的是汉字，不过这也无可厚非，谁叫中华文化圈需要这么多字才能满足基本使用呢。此外，这里面还有一块是「私用区」，意思就是用户可以自定义这一块的内容，标准不做规定。值得注意的是，第 0 平面还有一块叫「UTF-16 代理区」，这是什么？我们下节再说。

![UnicodeBMP](characters-and-encodings/UnicodeBMP.png)

接着是第 1 平面，叫「多文种补充平面」，下图是该平面内的大致字符分布。这个平面主要收录符号，以及一些冷门语言、历史语言所使用的文字。你可以在这个平面内见到埃及圣书体、楔形文字、西夏文等等文字，以及象棋、扑克、麻将之类的符号，还有人们喜闻乐见的表情符号（😉）。可以看到，这个平面内还有许多空白没有分配，再一次证明这么多码位肯定足够我们使用了。

![UnicodeSMP](characters-and-encodings/UnicodeSMP.png)

剩下的平面……其实没什么好看的。第 2 平面叫「表意文字补充平面」，第 3 平面叫「表意文字第三平面」，这两个平面里面分配好的全是汉字，总计 70670 个。第 4 至 13 平面还未启用。第 14 平面叫「特殊用途补充平面」，里面塞了一些控制字符。第 15、16 平面全是私用区，真是大手笔啊！

这就是 Unicode，统一全球字符的字符集。如果你想了解字符集的更多细节，可以去 Unicode 官网获取最新版的字符表——一个几千页的 PDF 文件！[^Unicode]

[^Unicode]: 网址是 [https://www.unicode.org/versions/latest/](https://www.unicode.org/versions/latest/)，在第 I 小节「List of Components」可以找到字符表（Code Charts）的 PDF 链接。

#### UTF 编码方案

「为 Unicode 字符集编码」这个事情，需要一点创造力。像 GB 18030 一样直接使用字符集的码位值肯定是不行的，因为 Unicode 字符集的字符码覆盖了 0ʜ~10FFFFʜ 的每个自然数，而直接用会引起歧义，不妨以「U 盘」这个词为例，把它每个字符的字符码写出来连在一起，就是 `5576D8`，但是要想还原回去就难了：

![Unicode直接编码](characters-and-encodings/UnicodeEncoding.png)

任意长的字符码让我们无法知道哪里是字符的开始，哪里又该是这个字符的结束。

那不如……把编码弄成定长的，而且长度要能容下最大的字符码吧？这就是 UTF-32 所想的。师承自 ISO 的编码方案，UTF-32 使用 32 位二进制码（4 字节）来编码字符，要知道，最大的 Unicode 码位 10FFFFʜ 也才 21 位二进制码，这显然绰绰有余，做到一字符一码。于是，在 UTF-32 下，「U 盘」一词的编码就是 `00000055000076D8`，真长啊。相信你也看出来了，UTF-32 的弊端就是占空间，存储大多数文本的时候，数据有一半多会是纯纯的 `0`，多浪费啊。所以，这种编码方式并没有推广开来。

另一种编码方案源自早期 Unicode 设想中的「宽体 ASCII」方案，使用 16 位二进制码来编码，这就是 UTF-16 的雏形。位于基本区的内容，除去之前看到的「UTF-16 代理区」，利用 16 位二进制码（2 字节），直接写字符的 Unicode 字符码就可以了，例如「U 盘」一词的 UTF-16 编码就是 `005576D8`。但剩下的平面，16 位二进制不够用，怎么办呢？这就是 UTF-16 代理区的用武之地了。

UTF-16 代理区占据了 `U+D800`~`U+DFFF` 的区域，一共 2048 个码位，其中 `U+D800`~`U+DBFF` 的 1024 个是「高位代理」，剩下 1024 个是「低位代理」，这些都是虚拟字符。不在基本区的字符，将它的字符码拆成高、低两截，利用高位、低位代理字符各一个组成一个「代理对」，以两个 2 字节「代理」原本的字符。以「俨骖𬴂于上路，访风景于崇阿。」[^滕王阁序]中的 `U+2CD02`「𬴂」为例，我们来看看代理对是如何工作的。

[^滕王阁序]: 选自唐朝文学家王勃所写的《滕王阁序》。

稍微看一看高位代理的码位范围，不难发现，如果利用二进制表示，高位代理会长下面这个样子，其中 `X` 是可变的位置。
```
1101 10XX XXXX XXXX
```
也就是说，只要以 `1101 10` 开头的 UTF-16 编码，就是一个高位代理。相应地，低位代理就长下面这样，相比高位代理的特征就差一位。
```
1101 11XX XXXX XXXX
```

想必你应该不难想到这些「可变的位置」的作用了吧。接下来，我们想表示「𬴂」，要分两步走：
1. 在表示基本区外的字符时，要将它的 Unicode 字符码减去 10000ʜ；
2. 把它的 Unicode 字符码填进代理对的可变位置就行了，前面没有用到的位置补 0 即可，像这样：

![UTF16](characters-and-encodings/UTF16.png)

于是 `U+2CD02`「𬴂」的 UTF-16 编码就是 `D873DD02`。

> UTF-16 代理区的字符只有「一高一低」的序列才是有效的，其他情况都不行。（实际解析出来大概率会是「�」。）

一个代理字符有 10 位二进制的可变位，所以利用代理对可以表示的字符总共有{{<katex>}}2^{20} = 1\,048\,576 = \mathrm{100000}_\mathrm{H}{{</katex>}}个。再加上无需代理的基本区的 10000ʜ（= 65536）个，正好是 Unicode 字符集的 110000ʜ 个码位。而 20 位二进制数，代表的数值范围是 0ʜ~FFFFFʜ，对应着不属于基本区的 `U+10000`~`U+10FFFF`，这就是为什么代理对表示法的第一步是「减去 10000ʜ」。同时这也是为什么 Unicode 字符集一共 110000ʜ 个码位——正是为了兼容 UTF-16 作出的限制。

相比于 UTF-32，UTF-16 的编码长度要短许多，如果一份文本使用的是位于基本区的常用字符，那就能省下一半的空间。即便是存储不再寸土寸金的今天，省下一半的空间也意味着巨大的优势。如今的 Windows 系统与 Java 编程语言都在使用 UTF-16 作为文本编码。但是 UTF-16 也有弊端，它是唯一广泛使用，但不兼容 ASCII 的编码。有没有一种既能表示 Unicode 这么多字符，又兼容 ASCII 的编码呢？还真有，而且是一个颇具想象力的方案。

UTF-8 是一种彻彻底底的变长编码方案，它的单字符编码码长不像之前的两个 UTF 限制在 2 字节与 4 字节，而是 1 到 7 字节都可行（不过实际上用不到这么多）。

首先，UTF-8 兼容 ASCII，所以单字节编码 `00`~`7F` 就是 ASCII 范围了。但这些也是 UTF-8 仅有的单字节编码，剩下的都是多字节。为了标记多字节编码的字节数量，UTF-8 把剩下的字节值分成了「领头字节」与「跟随字节」两种。领头字节的形式是 `110XXXXXʙ`、`1110XXXXʙ`……`11111110ʙ`，它的意思是：第一个 `0` 前面有几个 `1`，那么这个编码就是几字节。跟随字节的形式是 `10XXXXXXʙ`，它跟在领头字节后面，共同组成整个多字节的字符编码。显然，{{<katex>}}n\;(n>1){{</katex>}}字节的编码就有 1 个领头字节和{{<katex>}}(n-1){{</katex>}}个跟随字节。这么规定下来，不同字节值在 UTF-8 编码中的职能可以总结成一张图：

![UTF-8字节使用](characters-and-encodings/UTF8Bytes.png)

稍微做一点点计算，我们可以列出一张表，把 UTF-8 编码与其可表示的 Unicode 字符码范围对应起来（假定表示的是 `U+UVWXYZ` 的字符码）：

| 字符码范围           | 码长  | UTF-8 编码二进制值                    |
| -------------------- | :---: | ------------------------------------- |
| `U+0000`~`U+007F`    |   1   | `0YYYZZZZ`                            |
| `U+0080`~`U+07FF`    |   2   | `110XXXYY 10YYZZZZ`                   |
| `U+0800`~`U+FFFF`    |   3   | `1110WWWW 10XXXXYY 10YYZZZZ`          |
| `U+10000`~`U+10FFFF` |   4   | `11110UVV 10VVWWWW 10XXXXYY 10YYZZZZ` |

要确定一个字符的 UTF-8 编码，只要先查表确定它是几字节，然后像 UTF-16 填代理对一样，把字符码填进对应编码的可变位置就可以了。还是「U 盘」一词，转换为 UTF-8 编码的过程是这样的：

![UTF8](characters-and-encodings/UTF8.png)

于是我们得到了「U 盘」的 UTF-8 编码——`55E79B98`。诚然，UTF-8 很好，但它也存在不足——譬如我们中文用户，常用汉字无论在 UTF-16 还是 GB18030 里面，都是 2 字节编码，但到 UTF-8 就要 3 字节，空间消耗多了一半。所以我国仍有不少用户在使用 GB18030 编码。

以上三种 UTF 编码方案，正是 Unicode 标准中规定的三种编码方案，而其中以 UTF-8 最为广泛使用。自互联网诞生以来的很长一段时间，全球的网络内容中大多数都是以 ASCII 为编码的，但 2008 年，UTF-8 超越了 ASCII，成为网络内容使用率排名第一的编码方案。之后，UTF-8 一路高歌猛进，到 2024 年，它已占据了网络内容 98% 的份额，逐渐成为了人们的共识。

> 为了兼容性考虑，其实三种 UTF 编码也有自己的代码页编号，你可以上网搜一搜相关内容。

#### 字体——所见不一定是所得

「Unicode 三板斧」中，字体承担的工作，是在电脑解析存储在文件中的编码，转换为 Unicode 字符码后，输出到屏幕这一环。也就是说，字体存储了字符的形状——「字形」，和与之相对应的 Unicode 字符码。但本节并不打算教你字体的原理或者制作方法，而是从它与 Unicode 之间的关系来谈谈一些杂事。虽然 Unicode 是一个字符集，但它并没有规定收录的字符应该长什么样子，甚至《Unicode 核心规范》中还特别声明「字符表中的字符图像并非规范，实际字体可能会有相当大的差异」。

不妨从我们最熟悉的汉字开始。众所周知，东亚所属中华文化圈的几个地方，或多或少在使用汉字。然而，汉字会在传播与使用中逐渐演化，各地人们的书写习惯、官方颁布的规范都可能会有所不同。就拿中国大陆、中国台湾、日本、韩国这几个地区为例吧，这几个地区都会向 Unicode 联盟提交汉字，难免会提交同一个字。但就算是同一个字，在各自字形写法规范下也会多少有些不同：

![CJK区别](characters-and-encodings/CJK.png)

每一排看起来或多或少有些差别，但它们却对应着同一个 Unicode 码位。这也向我们解释了一件事：为什么玩一些外国游戏的时候，里面的字看起来有点怪，尤其是「门」字总看起来像「冂」上挂一竖？实际上就是在做本地化工作的时候默认使用了适合日本标准的字体。

放眼全球，世界上的其他书写系统不一定像我们的汉字，或者欧美的拉丁字母，从左到右一路排过去就完事了。来看看天城文吧，印度次大陆上的书写系统，古时使用梵文的佛教经典与现在的印地语都由它写就。天城文有一个特点：当某些字母放在一起时，写在纸面的样子和它们各自独立出现时的样子几乎是两码事。此之谓「连字」，让我们来看看梵文的「爱」一词：

![天城字母](characters-and-encodings/Devanagari.png)

按 1 到 5 的顺序输入的 5 个字符，拼在一起却成了另一番模样，若是不熟悉这种文字，想必很难想象看起来连在一起的文字居然是由 5 个字符组成的。拉丁字母有时也有连字，但那大多数是为了好看，而天城文这样的书写系统，连字是它们表达方式的一部分。除天城文外，阿拉伯文，我国藏族的藏文，以及中南半岛上诸国的文字，例如高棉文、孟加拉文、缅文等，都有这样的连字。

再度审视《Unicode 核心规范》中的那句声明，「实际字体可能会有相当大的差异」，什么是「相当大」呢？如果我们激进一点，完全不参考字符表中的字形，而是另立门户，我们就可以创造出一种看起来完全不像世界上任何一种文字的全新书写系统。游戏《我的世界》中，附魔台上显示的，或者飘出来的文字就是一个例子。

<!-- 插图 -->

这种文字名叫「标准银河字母」（Standard Galactic Alphabet，简称 SGA），原本是《指挥官基恩》系列游戏中使用的文字，《我的世界》的开发者看它充满神秘感，于是将它添加到了同样充满神秘色彩的附魔台上。但实际上，SGA 只是重做了英文字母表而已，这些符号与英文字母都是一一对应的，但是如果不知道对应关系，一般人想要破译也还是有点难度的。

> 「重做英文字母表」恰好也是古典密码的一种——字母替换密码。欲了解更多有关密码的话题，可以前去 以密码之剑护网安之盾 一章。

如果不会设计字形，还有一种办法获得一个「加密字体」——把字形和 Unicode 字符码之间的对应关系打乱，例如本来 `U+4E00` 是汉字「一」，但你让它对应「霸」这个字……这样一来，使用这个字体的时候，按平常一样输入「一」，显示出来的却是「霸」，多有意思啊。不过我们不建议把这样的字体用于正式用途。

说了这么些，如果你真的想自己试试水，做一个字体，可以上网搜索「字体制作教程」之类的关键词，祝你好运！

## 赛博世界的鸡同鸭讲

### 恼人的乱码